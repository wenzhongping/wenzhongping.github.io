<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker实战</title>
      <link href="/2020/07/26/docker%E5%AE%9E%E6%88%98/"/>
      <url>/2020/07/26/docker%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1><span id="docker-部署实战">Docker 部署实战</span></h1><h2><span id="docker-第一章-简介">docker  第一章 简介</span></h2><p>Docker最初是dotCloud公司创始人Solomon Hykes在法国期间发起的一个公司内部项目,于2013年3月以Apache 2.0授权协议开源,主要项目代码在GitHub上进行维护。Docker使用Google公司推出的Go语言进行开发实现，是linux容器的一种封装,提供简单易用的容器使用接口.它是最流行的Linux容器解决方案。Docker的接口相当简单,用户可以方便的创建、删除容器。Docker将应用程序与程序的依赖,打包在一个文件里面，运行这个文件就会生成一个虚拟容器。程序运行在虚拟容器里,如同在真实物理机上运行一样,有了docker,就不用担心环境问题了。</p><h3><span id="11-为什么要用docekr">1.1 为什么要用docekr？</span></h3><p>传统物理机上部署应用：</p><ul><li><p>部署非常慢</p></li><li><p>成本非常高（时间成本，消耗运维成本）</p></li><li><p>资源浪费（消耗内存资源）</p></li><li><p>难于迁移和扩展</p></li><li><p>可能会被限定硬件厂商</p></li></ul><p>  虚拟机上部署应用：</p><ul><li>一个物理机可以部署多个APP且互不干扰</li><li>每个App独立运行在一个VM里面，系统资源相互独立</li></ul><p>  docker与虚拟机区别：</p><p>  启动：虚拟机分钟级，容器秒级</p><p>  硬盘使用：虚拟机GB级，容器MB</p><p>  性能：容器接近原生 ，虚拟机弱</p><p>  系统支持量：单机支持上千容器，虚拟机一般几十个</p><p>  虚拟机：</p><p>  缺点：</p><ul><li><p>(1)资源占用多<br>虚拟机会独占一部分内存和硬盘空间.<br>它运行的时候,其他程序就不能使用这些资源了.<br>哪怕虚拟机里面的应用程序,真正使用的内存只有1MB,<br>虚拟机依然需要几百MB的内存才能运行.</p><ul><li>(2)冗余步骤多<br>虚拟机是完整的操作系统,一些系统级别的操作步骤,往往无法跳过,比如用户登录.<ul><li>(3)启动慢<br>启动操作系统需要多久,启动虚拟机就需要多久.可能要等几分钟,应用程序才能真正运行.</li></ul></li></ul><p>优点：</p></li><li><p>(1)资源池 - 一个物理机的资源分配到了不同的虚拟机里</p><ul><li>(2)很容易扩展 - 加物理机器或加虚拟机<ul><li>(3)很容易云化 - 亚马逊AWS, 阿里云等</li></ul></li></ul></li></ul><p>  docker的优势：</p><ul><li>更快速的启动时间</li><li>持续交付和部署</li><li>更加轻松的迁移</li></ul><h2><span id="docker-第二章-安装">docker 第二章 安装</span></h2><pre><code class="bash"># 安装依赖包sudo yum install -y yum-utils device-mapper-persistent-data lvm2 # 设置阿里云镜像源sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 安装 Docker-CEsudo yum install docker-ce启动docker# 开机自启sudo systemctl enable docker # 启动docker服务  sudo systemctl start docker# 镜像加速配置cd /etc/docker/vi daemon.json{  "registry-mirrors": ["https://6ej57h0o.mirror.aliyuncs.com"]}# 重新启动docker服务  sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p>GUI管理插件安装</p><p>这里推荐使用 Portainer 作为容器的 GUI 管理方案。</p><p>官方地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fportainer.io%2Finstall.html" target="_blank" rel="noopener">https://portainer.io/install.html</a></p><pre><code class="bash">docker run --name portainer -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock  --restart=always docker.io/portainer/portainer</code></pre><p>访问你的 IP:9000 即可进入容器管理页面。</p><h2><span id="docker-第三章-常用运维命令">docker 第三章 常用运维命令</span></h2><pre><code class="bash">#查看当前运行中的dockerdocker ps # 查看 docekr 容器的详细信息docker inspect 容器名# 进入docker 容器docker exec -it zabbix-agent /bin/bash# 删除docker容器（若容器硬盘没映射到物理机，容器保存的数据会丢失）docker rm -f 容器名# 重启容器docker restart 容器名# 容器启动后再增加重启策略# 创建容器时没有添加参数  --restart=always ，导致的后果是：当 Docker 重启时，容器未能自动启动。docker container update --restart=always 容器名字# 下载镜像：docker pull &lt;镜像名:tag&gt;    如：下载centos镜像docker pull centosdocker pull sameersbn/redmine:latest# 查看已下载镜像docker images# 删除容器docker rm &lt;容器名 or ID&gt;# 查看容器日志docker logs -f &lt;容器名 or ID&gt;# 查看正在运行的容器docker ps# 查看所有的容器，包括已经停止的。docker ps -a # 删除所有容器docker rm $(docker ps -a -q)# 停止、启动、杀死指定容器docker start &lt;容器名 or ID&gt; # 启动容器docker stop &lt;容器名 or ID&gt; # 启动容器docker kill &lt;容器名 or ID&gt; # 杀死容器# 后台运行 docker run -d &lt;Other Parameters&gt;docker run -d -p 127.0.0.1:33301:22 centos6-ssh# 暴露端口： 一共有三种形式进行端口映射docker -p ip:hostPort:containerPort # 映射指定地址的主机端口到容器端口# 例如：docker -p 127.0.0.1:3306:3306 映射本机3306端口到容器的3306端口docker -p ip::containerPort # 映射指定地址的任意可用端口到容器端口# 例如：docker -p 127.0.0.1::3306 映射本机的随机可用端口到容器3306端口docer -p hostPort:containerPort # 映射本机的指定端口到容器的指定端口# 例如：docker -p 3306:3306 # 映射本机的3306端口到容器的3306端口# 映射数据卷docker -v /home/data:/opt/data # 这里/home/data 指的是宿主机的目录地址，后者则是容器的目录地址# docker 拷贝docker cp zabbix-web-nginx-mysql:/usr/share/zabbix/assets/fonts ./docker cp 容器名:容器路径 物理机路径</code></pre><h2><span id="docker-第四章-搭建zabbix">docker 第四章 搭建zabbix</span></h2><h3><span id="41-脚本搭建-zabbix-agent暂时只编写zabbix-agent的脚本其他可基于此修改">4.1 脚本搭建 zabbix-agent（暂时只编写zabbix-agent的脚本，其他可基于此修改）</span></h3><pre><code class="bash">#1.下载脚本git clone https://github.com/webf5/zabbix-agent.git# 2.切换到下载好的文件夹（需要修改成zabbix-server的ip）cd zabbix-agent/vim  zabbix-agent.yml -  ZBX_SERVER_HOST=修改成zabbix-server的ip# 3.执行脚本./docker_run.sh </code></pre><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image-20200726160257239.png" class title="image-20200726160257239"><h3><span id="42-搭建zabbix主程序使用一般docke命令创建">4.2 搭建zabbix主程序（使用一般docke命令创建）</span></h3><pre><code class="bash">#第一步:#先安装数据库mysql:docker run --name zabbix-mysql-server --hostname zabbix-mysql-server \-e MYSQL_ROOT_PASSWORD="123456" \-e MYSQL_USER="zabbix" \-e MYSQL_PASSWORD="123456" \-e MYSQL_DATABASE="zabbix" \-p 23306:3306 \-d mysql:5.7 \--character-set-server=utf8 --collation-server=utf8_bin# 第二步:# 2 创建zabbix-serverdocker run  --name zabbix-server-mysql --hostname zabbix-server-mysql \--link zabbix-mysql-server:mysql \-e DB_SERVER_HOST="mysql" \-e MYSQL_USER="zabbix" \-e MYSQL_DATABASE="zabbix" \-e MYSQL_PASSWORD="123456" \-v /etc/localtime:/etc/localtime:ro \-v ~/zabbix/alertscripts:/usr/lib/zabbix/alertscripts \-v ~/externalscripts:/usr/lib/zabbix/externalscripts \-p 10051:10051 \-d \--restart=always \zabbix/zabbix-server-mysql# 第三步也是最后一步:# 安装web-nginx# 最后安装zabbix-web-nginxdocker run --name zabbix-web-nginx-mysql --hostname zabbix-web-nginx-mysql \--link zabbix-mysql-server:mysql \--link zabbix-server-mysql:zabbix-server \-e DB_SERVER_HOST="mysql" \-e MYSQL_USER="zabbix" \-e MYSQL_PASSWORD="123456" \-e MYSQL_DATABASE="zabbix" \-e ZBX_SERVER_HOST="zabbix-server" \-e PHP_TZ="Asia/Shanghai" \-p 8880:8080 \-d \--restart=always \zabbix/zabbix-web-nginx-mysql</code></pre><p>这里说明下，mysql没做数据卷的映射，nginx也没做数据卷的映射，在实际生产环境下，最好做数据映射。防止数据丢失。</p><p>4.登录访问测试</p><p>浏览器访问ip:8880查看</p><p>默认登录</p><p>username:Admin</p><p>password:zabbix</p><p>搭建zabbix agent</p><pre><code class="bash">docker run --name zabbix-agent -e ZBX_HOSTNAME="172.16.16.4" -e ZBX_SERVER_HOST="172.16.16.5" -d -p 10050:10050 --restart=always zabbix/zabbix-agent</code></pre><h3><span id="43-配置界面">4.3 配置界面</span></h3>{% asset_img image.png image %}<p>选择主机模板</p>{% asset_img 2.png 2 %}{% asset_img image3.png image3 %}{% asset_img image4.png image4 %}<h3><span id="44-图形显示中文乱码解决办法">4.4 图形显示中文乱码解决办法</span></h3>{% asset_img image5.png image5 %}<pre><code class="bash">#1.把docker中的字体文件夹拷贝出来docker cp zabbix-web-nginx-mysql:/usr/share/zabbix/assets/fonts ./# 2.把电脑的字体文件songti.ttc拷贝到该目录，并把目录映射到docker中mv songti.ttc ./fonts/songti.ttc</code></pre><p>3.再重启起docker</p><pre><code class="bash">docker run --name zabbix-web-nginx-mysql --hostname zabbix-web-nginx-mysql \--link zabbix-mysql-server:mysql \--link zabbix-server-mysql:zabbix-server \-e DB_SERVER_HOST="mysql" \-e MYSQL_USER="zabbix" \-e MYSQL_PASSWORD="123456" \-e MYSQL_DATABASE="zabbix" \-e ZBX_SERVER_HOST="zabbix-server" \-e PHP_TZ="Asia/Shanghai" \-p 8880:8080 \-v ~/fonts-zabbix:/usr/share/zabbix/assets/fonts \-d \--restart=always \zabbix/zabbix-web-nginx-mysql</code></pre><p>4.先备份原有字体，再把新字体改成默认字体</p><pre><code class="bash">cp  DejaVuSans.ttf ./DejaVuSans.ttf.back# 5.把新字体的名字改成DejaVuSans.ttf，并覆盖mv DejaVuSans.ttc ./DejaVuSans.ttf</code></pre><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image-20200726174418913.png" class title="image-20200726174418913"><p>最终效果</p><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image9.png" class title="image9"><h3><span id="45-zabbix创建icmp模板">4.5 zabbix创建ICMP模板</span></h3><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image10.png" class title="image10"><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image11.png" class title="image11"><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image12.png" class title="image12"><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image13.png" class title="image13"><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image14.png" class title="image14"><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image15.png" class title="image15"><p>在主机配置中应用模板</p><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image16.png" class title="image16"><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image17.png" class title="image17"><p>微信告警：<a href="https://www.cnblogs.com/yanjieli/p/10840132.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanjieli/p/10840132.html</a></p><h2><span id="docker-第五章-部署rabbitmq">docker 第五章 部署RabbitMq</span></h2><pre><code class="bash">docker run -d --name rabbitmq -p 56710:5671 -p 56720:5672 -p 43690:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 -v /root/RabbitMq:/var/lib/rabbitmq  --restart=always rabbitmq:management</code></pre><p>访问<a href="http://ip:15672" target="_blank" rel="noopener">http://ip:15672</a></p><p>默认账号密码：guest/guest</p><h2><span id="docker-第六章-部署mysql">docker 第六章 部署mysql</span></h2><pre><code class="bash">docker run -d --name mysql -p 3307:3306 -v /root/data:/var/lib/mysql  -v /root/mysql:/etc/mysql  --restart=always -e MYSQL_ROOT_PASSWORD=passwd mysql#2 把需要的配置文件拷贝出来/var/lib/mysql  /etc/mysqldocker cp mysql:/var/lib/mysql /root/datadocker cp mysql:/etc/mysql /root/mysql# 3 进入docker的mysqldocker exec -it mysql /bin/bash# 4.给远程用户授权grant all on *.* to root@'%' ; flush privileges;# 允许远程登录#在映射出来的配置文件下找到mysqld配置文件#【mysqld】下添加bind-address = 0.0.0.0</code></pre><p>使用nginx代理mysql服务</p><pre><code class="bash"># 在stream下添加stream {#mysqlserver {       listen  33060;   proxy_pass mysql;}#mysqlupstream mysql {                server 127.0.0.1:3306 weight=3 max_fails=3 fail_timeout=30s;        }}</code></pre><h2><span id="docker-第七章-部署nginx">docker 第七章 部署nginx</span></h2><pre><code class="bash"># 1.先拉起一个doceker 为了拿nginx原始配置文件docker run --name nginx1 -d nginxdocker cp nginx1:/etc/nginx  /rootdocker rm -f nginx1# 1.正式拉起一个 nginxdocker run --name nginx-80 -v /root/nginx:/etc/nginx -d  -p  80:80   --restart=always  nginx </code></pre><h2><span id="docker-第八章-搭建jumpserver">docker  第八章 搭建jumpserver</span></h2><h3><span id="81-简介">8.1 简介</span></h3><p>官方文档：<a href="https://docs.jumpserver.org/zh/master/" target="_blank" rel="noopener">https://docs.jumpserver.org/zh/master/</a></p><h4><span id="简介">简介</span></h4><ul><li><p>JumpServer 是全球首款完全开源的堡垒机, 使用 GNU GPL v2.0 开源协议, 是符合 4A 的专业运维审计系统。</p></li><li><p>JumpServer 使用 Python / Django 进行开发, 遵循 Web 2.0 规范, 配备了业界领先的 Web Terminal 解决方案, 交互界面美观、用户体验好。</p></li><li><p>JumpServer 采纳分布式架构, 支持多机房跨区域部署, 中心节点提供 API, 各机房部署登录节点, 可横向扩展、无并发访问限制。</p></li><li><p>JumpServer 现已支持管理 SSH、 Telnet、 RDP、 VNC 协议资产。</p></li></ul><p>改变世界, 从一点点开始。</p><p> 特色优势</p><ul><li>开源: 零门槛，线上快速获取和安装；</li><li>分布式: 轻松支持大规模并发访问；</li><li>无插件: 仅需浏览器，极致的 Web Terminal 使用体验；</li><li>多云支持: 一套系统，同时管理不同云上面的资产； 云端存储: 审计录像云端存储，永不丢失； 多租户: 一套系统，多个子公司和部门同时使用。</li></ul><h3><span id="82-docker-compose部署">8.2 Docker-Compose部署</span></h3><pre><code class="bash"># 若未安装Docker-Compose参考如下代码：#1、下载sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose#2、增加权限sudo chmod +x /usr/local/bin/docker-compose#3.测试安装结果docker-compose --version# 从git下载docker compose并安装git clone https://github.com/jumpserver/Dockerfile.gitcd Dockerfilecat .envdocker-compose up -d</code></pre><p>遇到一个问题80端口被占用</p><p>解决办法：</p><pre><code class="bash">vim 3个docker-compose文件，把jms_nginx的80端口改成26680端口</code></pre>{% asset_img image-20200727095139162.png image-20200727095139162 %}{% asset_img image-20200727095214788.png image-20200727095214788 %}<h3><span id="83-关于jumpserver-持久化问题">8.3 关于jumpserver 持久化问题</span></h3>{% asset_img image-20200727095457865.png image-20200727095457865 %}<p>删库测试</p><pre><code class="bash">docker rm -f jms_mysql</code></pre><p>打开后马上报错</p><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image-20200727095606513.png" class title="image-20200727095606513"><pre><code class="bash">#重新运行docker-compose# docker-compose命令格式为# docker-compose -f XXX.yml up -d[root@ Dockerfile]docker-compose up -djms_redis is up-to-dateCreating jms_mysql ... donejms_core is up-to-datejms_guacamole is up-to-datejms_koko is up-to-datejms_nginx is up-to-date</code></pre><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image-20200727100049117.png" class title="image-20200727100049117"><p>查看之前修改的密码配置是否还在呢</p><h3><span id="添加用户并配置免密登录">添加用户并配置免密登录</span></h3><pre><code class="bash">#去到需要远程登录的机器生成公钥 cd .ssh/ssh-keygen -f testcat test#复制下密钥创建系统用户用</code></pre><h2><span id="docker-第九章-搭建gitlab">docker 第九章 搭建gitlab</span></h2><h3><span id="91-git常用命令">9.1 git常用命令</span></h3><pre><code class="bash">#  第一次需要初始化文件夹，之后不用git init # 关联远程仓库git remote add origin https://github.com/webf5/zabbix-agent.gitgit remote add origin https://github.com/webf5/zabbix-agent.git# 添加本地文件夹下所有文件git add . # 提交时候的标签git commit -m "first commit" #提交到主目录git push -u origin master# 注意按提示绑定邮箱和用户名，两个都需要绑定# 下载文件git clone https://github.com/webf5/zabbix.git</code></pre><h3><span id="92-安装">9.2 安装</span></h3><pre><code class="bash">docker run --detach --publish 6443:443 --publish 6680:80 --name gitlab --restart unless-stopped -v /root/app/github/gitlab:/etc/gitlab -v /root/app/github/log/gitlab:/var/log/gitlab -v /root/app/github/beginor/gitlab:/var/opt/gitlab beginor/gitlab-ce:11.0.1-ce.0</code></pre><p>装完之后改</p><p>vim /etc/gitlab/gitlab.rb</p>{% asset_img image18.png image18 %}<p>此处填写域名，不需要端口，这里只是克隆显示地址</p><pre><code class="bash"># 重置GitHubgitlab-ctl reconfigure# 重启githbugitlab-ctl restart</code></pre><p>502报错解决</p><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image-20200727101316327.png" class title="image-20200727101316327"><pre><code class="bash">一、异常现象：gitlab访问错误Whoops, GitLab is taking too much time to respond二、问题定位问题定位8080端口被占用：三、解决方案解决方案01：将占用的8080端口的进程杀死或者卸载占用8080端口的软件修改正在占用8080端口程序的端口运行重新启动gitlab解决方案02：将external_url添加一个未被使用的端口external_url 'http://192.168.45.146修改为没有使用的端口即可：external_url 'http://192.168.45.146:8899'将下面这3行打开注释默认注释：unicorn['port'] = 8088postgresql['shared_buffers'] = "256MB"postgresql['max_connections'] = 200</code></pre><p>gitlab常用命令：</p><pre><code class="bash">#重启配置，并启动gitlab服务    sudo gitlab-ctl reconfigure#启动所有 gitlab    sudo gitlab-ctl start#重新启动GitLab    sudo gitlab-ctl restart#停止所有 gitlab    sudo gitlab-ctl stop#查看服务状态    sudo gitlab-ctl status#查看Gitlab日志    sudo gitlab-ctl tail#修改默认的配置文件    sudo vim /etc/gitlab/gitlab.rb#检查gitlab    gitlab-rake gitlab:check SANITIZE=true --trace</code></pre><h2><span id="docker-第十章-部署-elk">docker 第十章 部署 ELK</span></h2><h3><span id="101-简介">10.1 简介</span></h3><p><strong>Filebeat 日志数据采集，Logstash 过滤，Elasticsearch 存储，Kibana 展示</strong></p><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image-20200727102012658.png" class title="image-20200727102012658"><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image-20200727102034590.png" class title="image-20200727102034590"><h3><span id="102-安装elasticsearch">10.2 安装Elasticsearch</span></h3><pre><code class="bash"># 1.先起一个docker拿到配置文件[root@ ELK]mkdir [root@ ELK] lselasticsearch[root@ ELK] docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.7.0# 2.复制/usr/share/elasticsearch/config文件docker cp elasticsearch:/usr/share/elasticsearch/config  /root/app/ELK/elasticsearch/# 3.正式创建docker(需要传入环境变量限制内存)docker run -d --name  elasticsearch -p 9300:9300 -p 9200:9200  -e "discovery.type=single-node"  -e ES_JAVA_OPTS="-Xms512m -Xmx512m" -v  /root/app/ELK/elasticsearch/config:/usr/share/elasticsearch/config -v /root/app/ELK/elasticsearch/data:/usr/share/elasticsearch/data --restart=always  elasticsearch:7.7.0# 4.在物理机编辑yml文件/root/app/ELK/elasticsearch/configcluster.name: "docker-cluster"network.host: 0.0.0.0http.cors.enabled: truehttp.cors.allow-origin: "*" discovery.zen.minimum_master_nodes: 1</code></pre><h3><span id="103-安装kibana">10.3 安装kibana</span></h3><pre><code class="bash"># 1.先简单运行一个容器，为了拿到配置文件映射回到本机docker run -d --name kibana -p 5601:5601 kibana:7.7.0# 2.进入容器 docker exec -it kibana /bin/bash  cd /usr/share/kibana/config/# 3.把这个配置文件复制出来[root@ ELK]# cd kibana/[root@ kibana]# ls[root@ kibana]# docker cp kibana:/usr/share/kibana/config/kibana.yml ./[root@ kibana]# lskibana.yml#  4用完容器，把容器删除docker rm -f kibana # 5.修改配置文件改成本机的elasticsearch地址# 6.正式run 容器并建立映射docker run --name kibana -d --restart=always --log-driver json-file --log-opt max-size=100m --log-opt max-file=2  -p 5601:5601 -v /root/app/ELK/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml -e ES_JAVA_OPTS="-Xms512m -Xmx512m"  kibana:7.7.0</code></pre><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image-20200727112305059.png" class title="image-20200727112305059"><p>curl 127.0.0.1:5601 测试</p><h3><span id="104-安装logstash">10.4 安装logstash</span></h3><pre><code class="bash"># 1.简单起一个docker把原始配置文件拷贝出来备用docker run -d --name logstash   logstash:7.7.0docker cp logstash:/usr/share/logstash/config /root/logstashdocker rm -f logstash #  2.修改配置修改conf文件elasticsearch server为实际elasticsearch ipvim  logstash.ymlelasticsearch server为实际elasticsearch ip# 3.正式run dockerdocker run -d --restart=always --log-driver json-file --log-opt max-size=100m --log-opt max-file=2 -p 15044:5044 --name logstash -v /root/logstash/config:/usr/share/logstash/config  -e ES_JAVA_OPTS="-Xms256m -Xmx256m"   logstash:7.7.0</code></pre><h3><span id="105-安装filebeat">10.5 安装filebeat</span></h3><pre><code class="bash">#1 先简单起一个dockerdocker run --name filebeat-test -d store/elastic/filebeat:7.7.0# 2 把这个文件映射出来docker cp filebeat-test:/usr/share/filebeat ./# 3.修改配置文件vim filebeat.yml output.logstashhost: 改成elasticsearch的 ip# 正式启动docker run --restart=always --log-driver json-file --log-opt max-size=100m --log-opt max-file=2  --name filebeat --user=root -d   -v /root/filebeat-conf:/usr/share/filebeat  -e ES_JAVA_OPTS="-Xms256m -Xmx256m"   store/elastic/filebeat:7.7.0</code></pre><h3><span id="106-kibana-7-汉化">10.6 kibana 7 汉化</span></h3><p>kibana 7 中官方加入了中文的选项</p><p>中文包在 /usr/share/kibana/node_modules/x-pack/plugins/translations/translations/zh-CN.jso</p><p>只需要在配置文件 kibana.yml 中加入</p><p>i18n.locale: “zh-CN”</p><h2><span id="docker-第十一章-部署jenkins">docker 第十一章 部署jenkins</span></h2><h3><span id="111-简介">11.1 简介</span></h3><p>  一般情况下，将一个项目部署到生产环境的流程如下：</p><p>  需求分析—原型设计—开发代码—内网部署-提交测试—确认上线—备份数据—外网更新-最终测试，如果发现外网部署的代码有异常，需要及时回滚。</p><p>   整个过程相当复杂而漫长，其中还需要输入不少的命令，比如上传代码，git的拉取或者合并分支等等。   Jenkins是目前非常流行的一款持续集成工具，可以帮助大家把更新后的代码自动部署到服务器上运行，整个流程非常自动化，你可以理解为部署命令操作的可视化界面。</p><p>​    Jenkins主要有三种安装方式</p><p>  下载官方war包，放到tomcat中直接运行。</p><p>  yum安装。 使用官方docker镜像。</p><p>  毫无疑问，既然有docker这么简单方便的工具，就没必要选择前两种复杂的安装方式了。</p><p>  首先安装docker</p><pre><code class="bash"># 1在主机上创建目录，并添加读写权限以便jenkins应用运行时读写文件mkdir /root/j_nodechmod 777 /root/j_node# 2.docker启动jenkinsdocker run -d --name jenkins -p 8081:8080 -p 50000:50000 -v /root/j_node:/var/jenkins_home jenkins/jenkins</code></pre><p>这里注意，如果是阿里云的话，安全策略需要暴露8081端口</p><p>通过网址访问 http://你的ip:8081</p><p>然后通过命令获取安装秘钥</p><p>docker logs jenkins</p><p>有了密码，输入后安装建议的插件，推荐的插件里就包含版本控制软件git。</p><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image19.png" class title="image19"><img src="/2020/07/26/docker%E5%AE%9E%E6%88%98/image20.png" class title="image20"><h2><span id="docker-第十二章-compose部署">docker 第十二章 compose部署</span></h2><h3><span id="121-docker-commpose安装">12.1 docker commpose安装</span></h3><pre><code class="bash">1、下载sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose2、增加权限sudo chmod +x /usr/local/bin/docker-compose3.测试安装结果docker-compose --version</code></pre><h3><span id="122-dcoker-compose模板">12.2 dcoker-compose模板</span></h3><pre><code class="bash"># 1、编辑yml文件version: "3"services:  zabbix-agent:    image: docker.io/zabbix/zabbix-agent    container_name: zabbix-agent    ports:      - 10050:10050    restart: always    environment:      -  ZBX_SERVER_HOST=172.16.16.5# 2.启动docker-compose -f zabbix-agent.yml up -d</code></pre><p>此处分享一个通过docker-compose的方式部署zabbix</p><p>docker-compose_zabbix.yml</p><pre><code class="bash">version: "3"services:   mysql:    image: mysql:5.7     container_name: zabbix-mysql-server    ports:       - 23306:3306    environment:      - MYSQL_ROOT_PASSWORD=123456      - MYSQL_USER=zabbix      - MYSQL_PASSWORD=123456      - MYSQL_DATABASE=zabbix     hostname: zabbix-mysql-server    restart: always  zabbix-server:    image: zabbix/zabbix-server-mysql    container_name: zabbix-server-mysql    hostname: zabbix-server-mysql    depends_on:       - mysql    environment:       - DB_SERVER_HOST=mysql      - MYSQL_USER=zabbix      - MYSQL_DATABASE=zabbix      - MYSQL_PASSWORD=123456    volumes:       - /etc/localtime:/etc/localtime:ro    ports:       - 10051:10051    restart: always  zabbix-web-nginx-mysql:    image: zabbix/zabbix-web-nginx-mysql    hostname: zabbix-web-nginx-mysql    container_name:  zabbix-web-nginx-mysql    depends_on:       - mysql      - zabbix-server    environment:       - DB_SERVER_HOST=mysql      - MYSQL_USER=zabbix      - MYSQL_PASSWORD=123456      - MYSQL_DATABASE=zabbix      - ZBX_SERVER_HOST=zabbix-server      - PHP_TZ=Asia/Shanghai    ports:       - 8880:8080    volumes:       - ${curDir}/DejaVuSans.ttf:/usr/share/zabbix/assets/fonts/DejaVuSans.ttf    restart: always</code></pre><p>Docker_run.sh</p><pre><code class="bash">#!/bin/bashcurDir=$(cd `dirname $0`; pwd)export curDir# export curDir=$(pwd)/usr/local/bin/docker-compose -f docker-compose_zabbix.yml up -d#echo ${curDir} #echo $dir#echo $dirCur</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDC网络运维</title>
      <link href="/2020/06/23/IDC%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/"/>
      <url>/2020/06/23/IDC%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h1><span id="网络运维">网络运维</span></h1><h2><span id="第一章-路由交换">第一章  路由交换</span></h2><h3><span id="11-华为交换机配置">1.1 华为交换机配置</span></h3><h4><span id="交换机堆叠">交换机堆叠</span></h4><pre><code class="bash"># 先把所有端口down&lt;HUAWEI&gt; system-view[~HUAWEI] stack[~HUAWEI-stack] stack member 1 renumber 1 inherit-config      //配置堆叠成员ID--默认为1，一般住堆叠设备不改，只需改变优先级Warning: The stack configuration of member ID 1 will be inherited to member ID 2 after the device resets. Continue? [Y/N]: y[*HUAWEI-stack] stack member 1 priority 150      //配置堆叠优先级（默认为100，修改更高确认主从）[*HUAWEI-stack] stack member 1 domain 10       //配置堆叠域编号[*HUAWEI-stack] quit[*HUAWEI] commit                                                //提交配置&lt;HUAWEI&gt;save                                                    //保存配置&lt;HUAWEI&gt;reboot                                               //重启设备[~HUAWEI] interface stack-port 1/1      //创建堆叠逻辑端口[*HUAWEI-Stack-Port1/1] port member-group interface 100ge 1/0/7 to 1/0/8[*HUAWEI-Stack-Port1/1] quit第二台设备[~HUAWEI-stack] stack member 1 renumber 2 inherit-config      //配置堆叠成员ID--默认为1，备份堆叠设备需修改[*HUAWEI] commit[~HUAWEI] quit&lt;HUAWEI&gt; save      //保存配置Warning: The current configuration will be written to the device. Continue? [Y/N]: y&lt;HUAWEI&gt; reboot      //重启设备Warning: The system will reboot. Continue? [Y/N]: y[*HUAWEI-stack] stack member 2 domain 10       //配置堆叠域编号，因SwitchB尚未重启，当前堆叠成员ID还是1，所以此时仍使用member 1来进行堆叠配置。如果重启则使用2[*HUAWEI] interface stack-port 2/2[*HUAWEI-Stack-Port1/2] port member-group interface 100ge 2/0/7 to 2/0/8 ，--》修改堆叠成员id后，接口1/0/7默认变为2/0/7 日志服务器[*HUAWEI-Stack-Port1/2] quit[*HUAWEI] commit[~HUAWEI] quit&lt;HUAWEI&gt; save      //保存配置Warning: The current configuration will be written to the device. Continue? [Y/N]: y&lt;HUAWEI&gt; reboot      //重启设备Warning: The system will reboot. Continue? [Y/N]: y# 第三步：等都重启好了，打开堆叠的端口，插上堆叠线</code></pre><p>查看光功率</p><pre><code class="bash">dis transceiver interface XGigabitEthernet 0/1/1 verbose </code></pre><p>查看所有配置</p><pre><code class="bash">sysdis cu</code></pre><p>把100G口一分四</p><pre><code class="bash">port split dimension interface 100GE1/0/7 to 100GE1/0/20 split-type 4*25GE重启</code></pre><p>配置三层口并配置ip</p><pre><code class="bash">int 100GE1/0/1undo portswitchcommitdescription to SWip address 10.1.1.10 255.255.255.252commit</code></pre><p>配置静态路由</p><pre><code class="bash">ip route-static 10.1.1.0 255.255.255.0 100GE1/0/1 172.22.2.2 description to S5560-test</code></pre><p>保存配置</p><pre><code class="bash">commitsave</code></pre><p>聚合口</p><pre><code class="bash">interface Eth-Trunk1 undo portswitch description to CMCC_5560 ip address 172.22.2.1 255.255.255.252interface 10GE1/0/2 description B03-S5560-T1/0/27 eth-trunk 1    </code></pre><p>清空交换机配置**</p><pre><code class="bash"># 1.启动交换机，按Ctrl+B进入交换机的BootRom菜单...7. skip current configuration ...# 选择 “7” 回车后选择“Y”# 选择 “0” 重新启动交换机此时交换机会以出厂设置进入没密码# 进入到交换机直接输入save 保存空配置，替换以前的配置文件# 输入reboot重启交换机，再选择“7”此时选择“N”，重启后再配置即可</code></pre><p>解除最大路由限制，设置同一目的地址最大路由条目32条</p><pre><code class="bash">max-ecmp-num 32 设置最大路由条目32条重启</code></pre><p>初始化配置</p><pre><code class="bash"># 设置主机名sysname HW-S6520# 设置北京时间clock timezone BeiJ add 08:00:00clock protocol ntp# 设置远程登录aclacl number 2110 description telnet rule 5 permit source 119.139.229.216 0 rule 25 permit source 14.162.59.0 0.0.0.127 telnet server enable telnet server acl 2110lldp global enablefan prefer-direction slot 1 port-to-power  fan prefer-direction slot 2 port-to-power  # 设置远程登录ip interface LoopBack0 line vty 0 4    authentication-mode scheme user-role network-operator protocol inbound telnet idle-timeout 30 0 ntp-service enable ntp-service source LoopBack0 ntp-service unicast-server 202.120.2.101 priority ntp-service unicast-server 133.100.9.2 # snmp 配置  snmp-agentsnmp-agent community read test acl 2110 snmp-agent sys-info version all  # 配置远程用户 aaa local-user test class manage password hash 密码 service-type ssh telnet terminal authorization-attribute user-role level-15 authorization-attribute user-role network-admin authorization-attribute user-role network-operator</code></pre><p>加优先级静态路由</p><pre><code class="bash">ip route-static 10.1.1.1 255.255.255.255 Vlan-interface2000 192.168.1.20 bfd echo-packet description test   per 100</code></pre><p>Qos限速</p><pre><code class="bash">traffic classifier 10M if-match anytraffic behavior 10M                        car cir 10240 traffic policy 10M  （或qos policy 100M  华三设备） classifier 10M behavior 10Minterface GigabitEthernet0/0/9 description U-10M-to-HongShouWangLuo-20111216 port link-type access port default vlan 210 traffic-policy 10M inbound    （或qos apply policy 100M inbound 华三设备） traffic-policy 10M outbound</code></pre><p>策略路由配置</p><pre><code class="bash"># 匹配源地址Acl 2220rule permit source 193.246.53.0 0.0.0.63rule permit source 193.246.51.93 0 #创建策略路由 ip policy-based-route PZ-CU&amp;CMCC node 9 if-match acl  2220apply next-hop 10.1.16.26</code></pre><h3><span id="12-华三交换机配置">1.2 华三交换机配置</span></h3><h4><span id="交换机堆叠">交换机堆叠</span></h4><pre><code class="bash"># 先把所有端口down掉第一台：irf member 1 pri 26saveint range ten 1/0/29 to ten 1/0/32shutquirf-port 1/1port group interface Ten-GigabitEthernet1/0/29port group interface Ten-GigabitEthernet1/0/30 port group interface Ten-GigabitEthernet1/0/31 port group interface Ten-GigabitEthernet1/0/32quint range ten 1/0/29 to ten 1/0/32undo shutqusave irf-port-config active 第二台：irf member 1 re 2saverebootirf member 2 pri 10saveint range ten 2/0/29 to ten 2/0/32shutquirf-port 2/2port group interface Ten-GigabitEthernet2/0/29port group interface Ten-GigabitEthernet2/0/30 port group interface Ten-GigabitEthernet2/0/31 port group interface Ten-GigabitEthernet2/0/32quint range ten 2/0/29 to ten 2/0/32undo shutqusave irf-port-config active 第三步：插上堆叠线，备机自动重启，重启后重新save f第四步：在主机dis int 查看端口状态，是否能看到2机端口</code></pre><p>Acl 配置</p><pre><code class="bash"># 需要写反掩码acl number 2110 description telnet rule 5 permit source 119.136.249.216 0  rule 10 permit source 130.241.64.30 0  rule 25 permit source 14.162.59.0 0.0.0.127 </code></pre><p>配置远程登录 以及新增用户名密码</p><pre><code class="bash">telnet server enabletelnet server acl 2110ssh server enablessh server acl 2110rsa local-key-pair createpublic-key local create dsauser-interface vty 0 4authentication-mode schemeprotocol inbound sshidle-timeout 30 0local-user testpassword cipher service-type ssh level 3ssh user test authentication-type password ip http enable ip https enable# 配置管理ipint loop 0dec GLip add 10.20.252.62 28qu</code></pre><p>配置交换机名字</p><pre><code class="bash">sysname CMCC_P05_S6520</code></pre><p>trunk口配置以及限速</p><pre><code class="bash">interface Ten-GigabitEthernet2/0/3 port link-mode bridge description to test port link-type trunk undo port trunk permit vlan 1 port trunk permit vlan 100 to 102 qos apply policy 3G inbound qos apply policy 3G outbound</code></pre><p>限速策略</p><pre><code class="bash"> [H3C-S5800-32F]traffic classifier XXX_100M  [H3C-S5800-32F-classifier-XXX_100M]if-match acl 3001  [H3C-S5800-32F-classifier-XXX_100M]quit  [H3C-S5800-32F]traffic behavior 100M   [H3C-S5800-32F-behavior-100M]car cir 102400 cbs 6400000 ebs 512 green pass red discard yellow pass  [H3C-S5800-32F-behavior-100M]quit  [H3C-S5800-32F]qos policy XXX_100M_in[H3C-S5800-32F-qospolicy-XXX_100M_in] classifier XXX_100M behavior 100M[H3C-S5800-32F-qospolicy-XXX_100M_in]quit  [H3C-S5800-32F]qos policy XXX_100M_out[H3C-S5800-32F-qospolicy-XXX_100M_out]classifier XXX_100M behavior 100M[H3C-S5800-32F-qospolicy-XXX_100M_out]quit</code></pre><p>Tunnel 配置</p><pre><code class="bash">interface Tunnel1 mode gre description BGP  bandwidth 102400 ip address 10.1.1.5 255.255.255.252 source 本端公网ip destination 对端公网ip#              对端：interface Tunnel1 description BGP        ip address 10.1.1.6 255.255.255.252 source 本端公网ip destination 对端公网ip service-loopback-group 1 tunnel bandwidth 102400#               </code></pre><h2><span id="第二章-波分传输">第二章 波分传输</span></h2><img src="/2020/06/23/IDC%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/image-20200702113007276.png" class title="image-20200702113007276"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2020/06/22/nginx/"/>
      <url>/2020/06/22/nginx/</url>
      
        <content type="html"><![CDATA[<h1><span id="nginx从入门到精通">Nginx从入门到精通</span></h1><h2><span id="第一章-nginx简介以及安装">第一章  Nginx简介以及安装</span></h2><h3><span id="11-nginx由来">1.1 Nginx由来</span></h3><p>Nginx是一个web应用及反向代理工具，由一名俄罗斯程序员(Igor)发明的。NGINX是一个免费的，开源的高性能HTTP服务器和反向代理，以及IMAP / POP3代理服务器。 NGINX以其高性能，稳定性，丰富的功能集，简单的配置和低资源消耗而闻名。</p><h3><span id="12-nginx特点">1.2 Nginx特点</span></h3><p>主要有三大应用场景：</p><ul><li>静态资源服务 （web静态网页）</li><li>反向代理服务（缓存，负载均衡）</li><li>API服务（OpenResty）</li></ul><h3><span id="13-nginx优势">1.3 Nginx优势</span></h3><ul><li><p>更快，单次请求更快，高峰期也更快</p></li><li><p>高扩展性，极具扩展性，它由多个不同功能、不同层次、不同类型且耦合度极高的模块组成，这种低耦合的设计，造就了它庞大的第三方模块</p></li><li><p>高可靠性，每个worker进程相对独立，master进程在某个worker进程出错时能迅速拉起新的worker进程nginx的可靠性来源于其核心框架代码的优秀设计、模块设计的简单性。</p></li><li><p>低内存消耗，一般情况下10000个非活跃的keep-alive连接仅消耗2.5M的内存</p></li><li><p>单机支持10万以上的并发连接</p></li><li><p>热部署</p></li></ul><h3><span id="14-nginx安装centos">1.4 Nginx安装(centos)</span></h3><p>（1）直接通过yum安装</p><pre><code class="bash">yum install -y  nginx</code></pre><p>（2）通过编译安装</p><pre><code class="bash"># 更换阿里cento7的yum源（可选）yum list wget# 若没有安装wgetyum -y install wget# 首先备份原版/etc/yum.repos.d/CentOS-Base.repocd /etc/yum.repos.d mv CentOS-Base.repo CentOS-Base.repo.bak # 下载阿里yum源 wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo #运行yum makecache生成缓存 yum clean allyum makecache# 安装nginx依赖yum -y install gcc gcc-c++ autoconf automake make yum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel# 添加www用户groupadd -f wwwuseradd -g www www# 创建一个目录并切换mkdir nginxcd nginx# 下载nginxwget http://nginx.org/download/nginx-1.18.0.tar.gz# 解压tar -zxvf nginx-1.18.0.tar.gz# 配置nginxcd nginx-1.18.0# 安装依赖yum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel# 编译安装./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-stream --with-http_gzip_static_module --with-http_sub_module --with-http_v2_module</code></pre><img src="/2020/06/22/nginx/image-20200620224324492.png" class title="image-20200620224324492"><pre><code class="bash"># 出现以上可以开始编译安装make &amp;&amp; make install</code></pre><p>安装成功，刚刚通过./configure –prefix=/usr/local/nginx指定安装在/usr/local/nginx</p><pre><code class="bash">#查看启动情况ps -ef|grep nginx#查看是否启动成功curl 127.0.0.1#查看端口情况lsof -i :80COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEnginx   25363 root    6u  IPv4  73747      0t0  TCP *:http (LISTEN)nginx   25365  www    6u  IPv4  73747      0t0  TCP *:http (LISTEN)</code></pre><p>添加到系统环境变量</p><pre><code class="bash">vim /lib/systemd/system/nginx.service# 加入如下内容[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.targetvim /etc/profile # 加入以下内容export NGINX_HOME=/usr/local/nginxexport PATH=$PATH:$NGINX_HOME/sbin# 执行source /etc/profile</code></pre><pre><code class="bash">#启动nginx服务systemctl start nginx# 开机自启systemctl enable nginx#快速停止服务nginx -s stop# 优雅退出nginx  -s quit#检查配置文件nginx -t#重新加载配置nginx -s reload # 查看版本nginx -v</code></pre><h2><span id="第二章-常见nginx配置">第二章 常见Nginx配置</span></h2><h3><span id="21-nginx日志">2.1 nginx日志</span></h3><p>（1）access log配置</p><pre><code class="bash">access_log /var/log/access_log.gz combined gzip flush=5m;# 指定外部log日志服务器access_log syslog:server=192.168.1.10 debug;# /var/log/access_log.gz 存放日志的路径，默认是logs/access.log# gzip 压缩日志# flush=5m 5分钟写入硬盘一次# 使用默认combined格式记录日志</code></pre><p>(2) 日志切割</p><pre><code class="bash"># 备份之前日志mv access_log.log access_log.back.log# 切割日志nginx -s reopen</code></pre><h3><span id="22-热部署">2.2 热部署</span></h3><p>热升级：</p><pre><code class="bash"># 1.备份原执行文件nginx 为nginx.oldmv /usr/local/nginx/sbin/nginx  /usr/local/nginx/sbin/nginx.old# 2.将新编译好的nginx执行文件拷过来# 下载新版本并编译安装过程参考1.4，安装目录不能与旧版本路径一样cp /usr/local/nginx-19/sbin/nginx  /usr/local/nginx/sbin/nginx# 3.向nginx主进程发送USR2 信号，通知nginx要对它进行升级ps -ef  | grep nginx</code></pre><img src="/2020/06/22/nginx/image-20200621163132648.png" class title="image-20200621163132648"><pre><code class="bash">#  向老进程发送USR2信号，告诉老进程升级 kill -USR2 6579 # 向老进程发送退出老work信号  kill -WINCH 6579 # 确定没问题再quit 老进程（6579进程） kill -QUIT 6579 ps -ef  | grep nginx #查看版本 nginx -v</code></pre><img src="/2020/06/22/nginx/image-20200621163952054.png" class title="image-20200621163952054"><p>回滚操作</p><pre><code class="bash"># 1.恢复旧的二进制文件mv /usr/local/nginx/sbin/nginx.old  /usr/local/nginx/sbin/nginx# 2.退出新版本nginx进程kill -HUP 19857kill -QUIT 19857# 查看版本nginx -v# 指定配置文件为旧版本所用配置文件nginx -c /usr/local/nginx/conf/nginx.conf# 重新加载nginx -s reload</code></pre><h3><span id="23-web应用">2.3 web应用</span></h3><p>nginx.conf配置中隐藏版本号</p><pre><code class="bash"> # 隐藏版本号     server_tokens off;</code></pre><p>进入nginx配置文件夹</p><img src="/2020/06/22/nginx/image-20200621174446530.png" class title="image-20200621174446530"><p>主要配置在nginx.conf,一般不去修改此文件，我们可以再新建一个文件夹用于存放后续http模块配置，把该文件夹引入到nginx.conf配置文件中的http体内</p><pre><code class="bash">mkdir conf.d# 在nginx.conf中引入配置文件vim nginx.confinclude  /usr/local/nginx/conf/conf.d/*.conf:wq</code></pre><pre><code class="bash">#  新建一个html建测试页面touch /usr/local/nginx/www/index.htmlecho "hello word" &gt;&gt; /usr/local/nginx/www/index.html# 进入/usr/local/nginx/conf/conf.d新增配置文件cd /usr/local/nginx/conf/conf.dvim www.test.confserver {    listen      80;    # 若有域名则写域名，可以根据域名来转发到不同页面    server_name  localhost;# 访问日志配置    access_log  /var/log/index.access.log  main;# 网页文件所在路径    root   /usr/local/nginx/www/;# 访问/目录时显示index.html页面    location / {          index  index.html index.htm;    }    }# 测试curl 127.0.0.1:8080</code></pre><h4><span id="root-和-alias-的区别">root   和 alias 的区别:</span></h4><p>(1)</p><pre><code class="bash">location /images/ {       root "/app/webroot"}访问： http://www.test.com/images/a.jpg  相当于文件系统路径 /app/webroot/images/a.jpg </code></pre><p>(2)</p><pre><code class="bash">location  /images/ {      alias  "/www/pictures/"; }访问： http://www.test.com/images/a.jpg  相当于文件系统路径/www/pictures/a.jpg </code></pre><h4><span id="https-配置-以及访问http强制跳转到-https">https 配置 以及访问http强制跳转到 https</span></h4><p>https的配置</p><pre><code class="bash"># 若有阿里云域名可以免费生成https证书# 把生成好的证书下载并解压到指定目录# 在之前配置的基础上新增监听443端口cd /usr/local/nginx/conf/conf.dvim www.test.confserver {    listen      80;    # 若有域名则写域名，可以根据域名来转发到不同页面    server_name  localhost;# 访问日志配置    access_log  /var/log/index.access.log  main;# 网页文件所在路径    root   /usr/local/nginx/www/;    # 新增监听443端口配置listen 443 ssl;   #SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。  #/etc/nginx/key/4094309_www.test.pem为证书所在目录。  ssl_certificate /etc/nginx/key/4094309_www.test.com.pem; #/etc/nginx/key/4094309_www.test.com.key为key所在目录ssl_certificate_key /etc/nginx/key/4094309_www.test.com.key;  ssl_session_timeout 5m;ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件。ssl_protocols TLSv1 TLSv1.1 TLSv1.2;   #使用该协议进行配置。ssl_prefer_server_ciphers on;# 访问/目录时显示index.html页面    location / {          index  index.html index.htm;    }  # 客户端访问http强制跳转到https  if ($ssl_protocol = "") { return 301 https://$host$request_uri; }   }</code></pre><h5><span id="正则匹配">正则匹配</span></h5><h6><span id="元字符">元字符</span></h6><ul><li>. 匹配除换行符以外的任意字符</li><li>\w 匹配字母或数字或下划线或汉字</li><li>\s 匹配任意的空白符</li><li>\d 匹配数字</li><li>^ 匹配字符串开始</li><li>$匹配字符串结束</li></ul><h6><span id="重复">重复</span></h6><ul><li>“*”重复零次或更多次</li><li>“+”重复一次或更多次</li><li>“？”重复零次或一次</li><li>“{n}”重复n次</li><li>“{n,}”重复n或更多次</li><li>“{n,m}”重复n到m次</li></ul><p><strong>location的用法</strong></p><ul><li>以 = 开头，表示精确匹配；如只匹配根目录结尾的请求，后面不能带任何字符串。</li><li>以^~ 开头，表示uri以某个常规字符串开头，不是正则匹配</li><li>以~ 开头，表示区分大小写的正则匹配;</li><li>以~* 开头，表示不区分大小写的正则匹配</li><li>以/ 开头，通用匹配, 如果没有其它匹配,任何请求都会匹配到</li></ul><p>比较常用的location匹配</p><pre><code class="bash">#uri包含/static即可匹配中location ^~ /static/ {root /webroot/static/;}# uri以.(gif|jpg|jpeg|png|css|js|ico)结尾location ~* .(gif|jpg|jpeg|png|css|js|ico)$ {root /webroot/res/;}# 匹配全部location  ~.*^ {root /webroot/res/;}</code></pre><p>防盗链技术</p><p>简单有效的防盗链手段：referer模块</p><p>场景：</p><p>某网站通过url引用了你的页面，当用户在浏览器上点击 url时，http请求的头部中会通过 referer头部，将该网站当前页面的url带上，告诉服务器本次请求 是 由这个页面发起的</p><pre><code class="bash"># referer模块指令# invalid_referer 允许访问时变量为空 ，不允许访问时变量值为1# 例子：常见的图片视频防盗链location ~* .(gif|jpg|png|swf|flv)$ {# 通过浏览器直接打开会有referer信息，也就是valid_referers值为1# none 代表没有referer#  blocked 代表有referer但是被防火墙或者是代理给去除了# www.wosoquan.com wosoquan.com  nginx会通过正则匹配，匹配到以上字符串值为0，否则为1valid_referers none blocked www.test.com test.com ;if ($invalid_referer) {# 若用户直接盗链接打开，则跳转至http://www.test.com/retrun.htmlrewrite ^/ http://www.test.com/retrun.html;#return 403;}}</code></pre><p><code>proxy_set_header</code>和<code>add_header</code>的区别</p><p>区别：<code>proxy_set_header</code>是<code>Nginx</code>设置请求头信息给上游服务器，<code>add_header</code>是<code>Nginx</code>设置响应头信息给浏览器。</p><ul><li><p>proxy_set_header</p><p>假如<code>Nginx</code>请求上游服务器时，添加额外的请求头，就需要使用proxy_set_header</p><p>例如：<code>proxy_set_header X-Request-URI $scheme://$host/$uri;</code></p></li><li><p>add_header</p><p><code>Nginx</code>响应数据时，要告诉浏览器一些头信息，就要使用<code>add_header</code>。例如跨域访问</p></li></ul><p>新增http头部信息</p><pre><code class="bash">server {#添加一个自定义头部信息add_header  server:test;# 插入X-Forward-For到 下游服务器proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;#插入X-Real-IP远端真实ipproxy_set_header X-Real-IP $remote_addr;}</code></pre><p>X-Forward-For 与X-Real-IP区别</p><ul><li>HTTP 头部X-Forward-For用户传递IP</li><li>HTTP 头X-Real-IP用户传递用户 IP</li></ul><img src="/2020/06/22/nginx/image-20200622141513297.png" class title="image-20200622141513297"><h3><span id="24反向代理负载均衡">2.4反向代理负载均衡</span></h3><p>如何理解反向代理？<br>Nginx是反向代理服务器，我们可以从下面的图来理解为什么是反向代理。以Nginx为中心，数据的流向是从Server到Nginx再到Client，注意我说的是数据（响应数据），而不是请求。我们都知道水流一定是从上游流到下游，所以给Server一个别称上游服务器，当然这个别称并不是我定义的。</p><img src="/2020/06/22/nginx/image-20200622135224719.png" class title="image-20200622135224719"><h4><span id="241-七层反向代理">2.4.1 七层反向代理</span></h4><p>负载均衡</p><pre><code class="bash">http {#新增上游服务器组upstream local {server 127.0.0.1:8080 weight 10 max_fails 3 fail_timeout 60 max_conns 3000 slow_start 30 ;server 127.0.0.1:8081 weight 20 max_fails 3 fail_timeout 60 max_conns 3000 slow_start 30 ;}server {listen 80 ;location / {#local为上面定义的上游服务器组名称proxy_pass http://local;}}}</code></pre><ul><li>Server      反向服务地址和端口</li><li>weight      权重，默认为1.weight越大权重越大</li><li>max_fails    失败次数，默认为1.超过最大次数主机被踢出</li><li>fail_timeout 踢出后重新探测时间 </li><li>backup 备用服务，主机宕机请求backup机器响应</li><li>max_conns 最大连接次数 默认为0 限制同时连接到单个服务器的最大连接数</li><li>slow_start 节点恢复时间  服务器权重从0恢复到标准的时间，默认为0，相当于缓慢启动</li></ul><p>Proxy_next_upstream</p><p>当上游返回失败的时候,我们是有些处理方法的，这个处理方法就是通过proxy_next_upstream这么一个指令来控制的。当然了该指令能够生效的前提是我们没有向客户端发送一个字节，即没有向客户端发送任何的内容，只要向客户端发送了一个字节了，说明上游服务已经生效了，那么我们就不能再选择一个新的上游服务了。所以它是在接收到请求并且在转发一个字节之前，nginx判定为错误，那么这个功能才能够生效。</p><pre><code class="bash">Syntax: proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 |http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...;Default: proxy_next_upstream error timeout;Context: http, server, locationerror:nginx与上游建立连接，读取响应发送请求等等这些过程当中出现错误，那么error都可以满足这样一个场景，这个错误指的是网络错误，比如TCP层等。timeout:超时，有connect timeout，read timeout，write timeout。那么配置了timeout可以命中这些场景，当命中这些场景可以重选上游服务。#监听到下错误时proxy_next_upstream生效（二选一） server{ proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504  non_idemponent; # 监听到下游服务器宕机后生效（二选一） # proxy_next_upstream  off ;</code></pre><p>proxy_intercept_errors 拦截上游失败响应</p><p>proxy_intercept_errors 当上游服务器响应头回来后，可以根据响应状态码的值进行拦截错误处理，与error_page 指令相互结合。用在访问上游服务器出现错误的情况下。</p><pre><code class="bash">server {location / {prxxy_intercept_errors on;error_page 500 /test.html;}}</code></pre><h4><span id="242-四层反向代理">2.4.2 四层反向代理</span></h4><pre><code class="bash">stream {upstream test  {server 127.0.0.1:8082 ;server 127.0.0.1:8083;}server {listen 13389 ;location / {#test为上面定义的上游服务器组名称proxy_pass http://test;}}}</code></pre><h3><span id="25-缓存">2.5 缓存</span></h3><pre><code class="bash"># nginx缓存空间配置，该配置定义在nginx配置文件的http模块server上方即可proxy_cache_path /etc/nginx/cachefiles levels=1:2 keys_zone=cache:10m max_size=100m inactive=60m use_temp_path=off;</code></pre><ul><li><p>proxy cache_path 缓存内容存放的目录文件</p></li><li><p>levels=1:2 Nginx为将要缓存的资源生成的key为f4cd0fbc769e94925ec5540b6a4136d0，那么key的最后一位0，以及倒数第2-3位6d作为两级的子目录，也就是该资源最终会被缓存到/path/to/cache/0/6d目录中</p></li><li><p>keys_zone 在共享内存中设置一块存储区域来存放缓存的key和metadata（类似使用次数），这样nginx可以快速判断一个request是否命中或者未命中缓存，1m可以存储8000个key，10m可以存储80000个key</p></li><li><p>max_size最大cache空间，如果不指定，会使用掉所有disk space，当达到配额后，会删除最少使用的cache文件</p></li><li><p>inactive未被访问文件在缓存中保留时间，本配置中如果60分钟未被访问则不论状态是否为expired，缓存控制程序会删掉文件</p></li><li><p>use_temp_path  #如果为off，则nginx会将缓存文件直接写入指定的cache文件中，而不是使用temp_path存储，官方建议为off，避免文件在不同文件系统中不必要的拷贝</p></li></ul><pre><code class="bash"># 在 location中应用缓存location / {# 设置上面定义的zoom名字proxy_cache cache# 设置缓存的Key值proxy_cache_key $scheme$proxy_host$request_uri; # cache记录保存时间为1天 proxy_cache_valid any 1d;# 设置绕过缓存的请求url，即url中包含该配置的值，则该请求不从缓存中获取数据，非必须配置proxy_cache_bypass $arg_noCache;#设置当这两个参数值为true时，不缓存proxy_cache_bypass $cookie_nocache $arg_nocache;# 此处是托底配置，旧的总比出错强，当nginx请求后台服务器报错的时候，如果返回配置的错误响应码，nginx则直接取缓存文件中的旧数据返回给用户proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;# 缓存并发锁，当nginx缓存没有命中的时候只有一个请求回源后端服务器请求数据，其他请求会等待proxy_cache_lock on;#等待锁超时时间设置proxy_cache_lock_timeout 1s;# proxy_cache_revalidate命令被启用，NGINX检测得知当前的缓存内容依然有效（If-Modified-Since或者If-None-Match）proxy_cache_revalidate on;#允许在后台发送子请求来更新过期的缓存文件proxy_cache_background_update on;#指定该虚拟服务器下什么类型的HTTP方法可以被缓存proxy_cache_methods GET HEAD;#设置某内容被N次请求后，Nginx缓存该内容。proxy_cache_min_uses 1;# 强制缓存proxy_ignore_headers X-Accel-Expires Expires Cache-Control;# 插入头部信息查看缓存状态 add_header X-Cache-Status $upstream_cache_status;}</code></pre><h3><span id="26-分块缓存技术">2.6 分块缓存技术</span></h3><p>ngx_http_slice_filter_module模块默认没有编译到Nginx程序中，需要编译时添加–with-http_slice_module选项</p><p>Nginx的slice模块可以将一个请求分解成多个子请求，每个子请求返回响应内容的一个片段，让大文件的缓存更有效率。</p><pre><code class="bash">location / {    slice             1m;    proxy_cache       cache;    proxy_cache_key   $uri$is_args$args$slice_range;    proxy_set_header  Range $slice_range;    proxy_cache_valid 200 206 1h;    proxy_pass        http://127.0.0.1:80;}</code></pre><p>slice指令设置分片的大小为1m。 这里使用了proxy_set_header指令，在取源时的HTTP请求中添加了Range头部，向源服务器请求文件的一部分，而不是全部内容。在proxy_cache_key中添加slice_range变量这样可以分片缓存</p><h4><span id="slice_range变量">slice_range变量</span></h4><p>slice_range这个变量作用非常特殊，这个变量的值是当前需要向源服务器请求的分片，如果分片的大小为1m，那么最开始变量的值为<code>bytes=0-1048575</code>，通过配置文件中的<code>proxy_set_header Range $slice_range;</code>可以知道取源时请求的Range头部为<code>Range:bytes=0-1048575</code>，源服务器如果支持Range请求，便会返回响应的前1m字节，得到这个响应后slice_range变量的值变为<code>bytes=1048576-2097171</code> ，再次取源时便会取后1m字节，依次直到取得全部响应内容。</p><img src="/2020/06/22/nginx/image-20200622151506812.png" class title="image-20200622151506812"><h3><span id="25-rewrite详解">2.5 rewrite详解</span></h3><h4><span id="rewrite在if中的用法">rewrite在if中的用法</span></h4><p>格式：if (条件判断) { 具体的rewrite规则 }</p><pre><code class="bash">if条件判断语句由Nginx内置变量、逻辑判断符号和目标字符串三部分组成。其中，内置变量是Nginx固定的非自定义的变量，如，$request_method, $request_uri等。逻辑判断符号，有=, !=, ~, ~*, !~, !~*!表示相反的意思，~为匹配符号，它右侧为正则表达式，区分大小写，而~*为不区分大小写匹配。目标字符串可以是正则表达式，通常不用加引号，但表达式中有特殊符号时，比如空格、花括号、分号等，需要用单引号引起来。</code></pre><p><strong>示例1：当http请求方法为post时，返回403状态码</strong></p><pre><code class="bash">if ($request_method = POST){    return 403; }</code></pre><p><strong>示例2：通过浏览器标识匹配关键字，禁止IE浏览器访问</strong></p><pre><code class="bash">if ($http_user_agent ~* MSIE) {    return 403;}</code></pre><p>限制多个浏览器：</p><pre><code class="bash">if ($http_user_agent ~* "MSIE|firefox|Chrome"){    return 403;}</code></pre><p><strong>示例3：当请求的文件不存在时，进行重定向或return状态码等处理操作</strong></p><pre><code class="bash">if(!-f $request_filename){    rewrite 语句;}</code></pre><p><strong>示例4：判断uri中某个参数的内容</strong></p><pre><code class="bash"># \d表示数字，{6,8}表示数字出现的次数是6到8次，当uri中gid参数的值包含6-8个数字那么执行rewrite语句if($request_uri ~* 'gid=\d{6,8}/') {    rewrite 语句;}</code></pre><h4><span id="rewrite中break和last的用法">rewrite中break和last的用法</span></h4><p>两个指令用法相同，但含义不同，需要放到rewrite规则的末尾，用来控制重写后的链接是否继续被nginx配置执行(主要是rewrite、return指令)。</p><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/wwwroot/test.com;    rewrite /1.html /2.html;    rewrite /2.html /3.html;}</code></pre><p>请求1.html文件时，会被重定向到2.html，然后被重定向到3.html，最后返回的文件为3.html</p><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/test.com;    rewrite /1.html /2.html break;    rewrite /2.html /3.html;}</code></pre><p>请求1.html文件时，会被重定向到2.html，然后直接返回2.html，break在此处的作用就是当匹配第一个rewrite指令成功时，不执行后面的rewrite指令</p><p><strong>示例2：当break后面还有location{}的情况</strong></p><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/test.com;    rewrite /1.html /2.html break;    rewrite /2.html /3.html;    location /2.html {        return 403;    }}</code></pre><p>请求1.html文件时，会返回403状态码，当1.html被重定向到2.html时，break不会匹配后面的rewrite规则，但条件2.html匹配location{}定义的文件2.html，所以会执行return 403</p><p>以上两个示例中，将break换成last效果一样</p><h5><span id="2break和last在location内部时">2.break和last在location{}内部时</span></h5><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/test.com;    location / {        rewrite /1.html /2.html;        rewrite /2.html /3.html;    }    location /2.html    {        rewrite /2.html /a.html;    }    location /3.html    {        rewrite /3.html /b.html;    }}</code></pre><p>请求1.html，会经过两次重定向到3.html，3.html又刚好匹配location /3.html{}，所以返回b.html，当请求2.html时，会直接返回a.html，因为location /2.html {} 更精准，优先匹配</p><p><strong>示例1：在rewrite后面添加break</strong></p><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/test.com;    location / {        rewrite /1.html /2.html break;        rewrite /2.html /3.html;    }    location /2.html    {        rewrite /2.html /a.html;    }    location /3.html    {        rewrite /3.html /b.html;    }}</code></pre><p>请求1.html，会返回2.html，不会返回a.html，当break再location {} 内部时，遇到break后，当前location{} 以及后面的location{} 的指令都不再执行</p><p><strong>示例2：在rewrite后面添加last</strong></p><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/test.com;    location / {        rewrite /1.html /2.html last;        rewrite /2.html /3.html;    }    location /2.html    {        rewrite /2.html /a.html;    }    location /3.html    {        rewrite /3.html /b.html;    }}</code></pre><p>请求1.html时，会返回a.html，在location {} 内部遇到last，当前location {}中剩下的指令不会再执行，但被重定向的url会重新匹配一遍location {}</p><p><strong>break和last用法总结</strong></p><p>1.当rewrite规则在location{}外，break和last作用一样，遇到break或last后，其后续的rewrite/return语句不再执行。但后续有location{}的话，还会近一步执行location{}里面的语句,前提是请求能匹配该location<br>2.当rewrite规则在location{}里，遇到break后，本location{}与其他location{}的所有rewrite/return规则都不再执行<br>3.当rewrite规则在location{}里，遇到last后，本location{}里后续rewrite/return规则不执行，但重写后的url再次从头匹配所有location</p><h4><span id="动静态请求分离跳转">动静态请求分离跳转</span></h4><pre><code class="bash">server{    listen 80;    server_name www.test.com;    location ~* .*\.(jpg|jpeg|gif|css|png|js)$    {        rewrite /(.*) http://img.test.com/$1 permanent;    }}</code></pre><h4><span id="http跳转https">http跳转https</span></h4><pre><code class="bash">server{    listen 80;    server_name www.test.com;    rewrite /(.*) https://www.test.com/$1 permanent;}</code></pre><h2><span id="第三章-nginx优化">第三章 Nginx优化</span></h2><h3><span id="1-nginx运行工作进程数量">1、Nginx运行工作进程数量</span></h3><p>Nginx运行工作进程个数一般设置CPU的核心或者核心数x2。如果不了解cpu的核数，可以top命令之后按1看出来，也可以查看/proc/cpuinfo文件 grep ^processor /proc/cpuinfo | wc -l</p><pre><code class="bash">[root@lx~]# vi/usr/local/nginx1.10/conf/nginx.confworker_processes 4;[root@lx~]# /usr/local/nginx1.10/sbin/nginx-s reload[root@lx~]# ps -aux | grep nginx |grep -v greproot 9834 0.0 0.0 47556 1948 ?     Ss 22:36 0:00 nginx: master processnginxwww 10135 0.0 0.0 50088 2004 ?       S   22:58 0:00 nginx: worker processwww 10136 0.0 0.0 50088 2004 ?       S   22:58 0:00 nginx: worker processwww 10137 0.0 0.0 50088 2004 ?       S   22:58 0:00 nginx: worker processwww 10138 0.0 0.0 50088 2004 ?       S   22:58 0:00 nginx: worker process</code></pre><h3><span id="2-nginx运行cpu亲和力">2、Nginx运行CPU亲和力</span></h3><p>比如4核配置：</p><p>worker_processes 4;<br>worker_cpu_affinity 0001 0010 0100 1000<br>比如8核配置：</p><p>worker_processes 8;<br>worker_cpu_affinity 00000001 00000010 00000100 0000100000010000 00100000 01000000 10000000;<br>worker_processes最多开启8个，8个以上性能提升不会再提升了，而且稳定性变得更低，所以8个进程够用了。</p><h3><span id="3-nginx最大打开文件数">3、Nginx最大打开文件数</span></h3><p>worker_rlimit_nofile 65535;<br>这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n的值保持一致。</p><p>注：文件资源限制的配置可以在/etc/security/limits.conf设置，针对root/user等各个用户或者*代表所有用户来设置。</p><ul><li>soft nofile   65535</li><li>hard nofile   65535<br>用户重新登录生效（ulimit -n）</li></ul><h3><span id="4-nginx事件处理模型">4、Nginx事件处理模型</span></h3><p>events {<br>  use epoll;<br>  worker_connections 65535;<br>  multi_accept on;<br>}<br>nginx采用epoll事件模型，处理效率高。</p><p>work_connections是单个worker进程允许客户端最大连接数，这个数值一般根据服务器性能和内存来制定，实际最大值就是worker进程数乘以work_connections。</p><p>实际我们填入一个65535，足够了，这些都算并发值，一个网站的并发达到这么大的数量，也算一个大站了！</p><p>multi_accept 告诉nginx收到一个新连接通知后接受尽可能多的连接，默认是on，设置为on后，多个worker按串行方式来处理连接，也就是一个连接只有一个worker被唤醒，其他的处于休眠状态，设置为off后，多个worker按并行方式来处理连接，也就是一个连接会唤醒所有的worker，直到连接分配完毕，没有取得连接的继续休眠。当你的服务器连接数不多时，开启这个参数会让负载有一定的降低，但是当服务器的吞吐量很大时，为了效率，可以关闭这个参数。</p><h3><span id="5-开启高效传输模式">5、开启高效传输模式</span></h3><pre><code class="bash">http {  include mime.types;  default_type application/octet-stream;  ……  sendfile on;  tcp_nopush on;  ……}</code></pre><p>Include mime.types ： 媒体类型,include 只是一个在当前文件中包含另一个文件内容的指令。</p><p>default_type application/octet-stream ：默认媒体类型足够。</p><ul><li><p>sendfile on：开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</p></li><li><p>tcp_nopush on：必须在sendfile开启模式才有效，防止网路阻塞，积极的减少网络报文段的数量（将响应头和正文的开始部分一起发送，而不一个接一个的发送。）</p></li></ul><h3><span id="6-连接超时时间">6、连接超时时间</span></h3><p>主要目的是保护服务器资源，CPU，内存，控制连接数，因为建立连接也是需要消耗资源的。</p><pre><code class="bash">keepalive_timeout 60;tcp_nodelay on;client_header_buffer_size 4k;open_file_cache max=102400 inactive=20s;open_file_cache_valid 30s;open_file_cache_min_uses 1;client_header_timeout 15;client_body_timeout 15;reset_timedout_connection on;send_timeout 15;server_tokens off;client_max_body_size 10m;keepalived_timeout ：客户端连接保持会话超时时间，超过这个时间，服务器断开这个链接。tcp_nodelay：也是防止网络阻塞，不过要包涵在keepalived参数才有效。client_header_buffer_size 4k：客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过 1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。open_file_cache max=102400 inactive=20s ：这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。open_file_cache_valid 30s：这个是指多长时间检查一次缓存的有效信息。open_file_cache_min_uses 1 ：open_file_cache指令中的inactive 参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive 时间内一次没被使用，它将被移除。client_header_timeout ： 设置请求头的超时时间。我们也可以把这个设置低些，如果超过这个时间没有发送任何数据，nginx将返回request time out的错误。client_body_timeout设置请求体的超时时间。我们也可以把这个设置低些，超过这个时间没有发送任何数据，和上面一样的错误提示。reset_timeout_connection ：告诉nginx关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间。send_timeout ：响应客户端超时时间，这个超时时间仅限于两个活动之间的时间，如果超过这个时间，客户端没有任何活动，nginx关闭连接。server_tokens ：并不会让nginx执行的速度更快，但它可以关闭在错误页面中的nginx版本数字，这样对于安全性是有好处的。client_max_body_size：上传文件大小限制。</code></pre><h3><span id="7-fastcgi-调优">7、fastcgi 调优</span></h3><pre><code class="bash">fastcgi_connect_timeout 600;fastcgi_send_timeout 600;fastcgi_read_timeout 600;fastcgi_buffer_size 64k;fastcgi_buffers 4 64k;fastcgi_busy_buffers_size 128k;fastcgi_temp_file_write_size 128k;fastcgi_temp_path/usr/local/nginx1.10/nginx_tmp;fastcgi_intercept_errors on;fastcgi_cache_path/usr/local/nginx1.10/fastcgi_cache levels=1:2 keys_zone=cache_fastcgi:128minactive=1d max_size=10g;fastcgi_connect_timeout 600 ：指定连接到后端FastCGI的超时时间。fastcgi_send_timeout 600 ：向FastCGI传送请求的超时时间。fastcgi_read_timeout 600 ：指定接收FastCGI应答的超时时间。fastcgi_buffer_size 64k ：指定读取FastCGI应答第一部分需要用多大的缓冲区，默认的缓冲区大小为。fastcgi_buffers指令中的每块大小，可以将这个值设置更小。fastcgi_buffers 4 64k ：指定本地需要用多少和多大的缓冲区来缓冲FastCGI的应答请求，如果一个php脚本所产生的页面大小为256KB，那么会分配4个64KB的缓冲区来缓存，如果页面大小大于256KB，那么大于256KB的部分会缓存到fastcgi_temp_path指定的路径中，但是这并不是好方法，因为内存中的数据处理速度要快于磁盘。一般这个值应该为站点中php脚本所产生的页面大小的中间值，如果站点大部分脚本所产生的页面大小为256KB，那么可以把这个值设置为“8 32K”、“4 64k”等。fastcgi_busy_buffers_size 128k ：建议设置为fastcgi_buffers的两倍，繁忙时候的buffer。fastcgi_temp_file_write_size 128k ：在写入fastcgi_temp_path时将用多大的数据块，默认值是fastcgi_buffers的两倍，该数值设置小时若负载上来时可能报502BadGateway。fastcgi_temp_path  ：缓存临时目录。fastcgi_intercept_errors on ：这个指令指定是否传递4xx和5xx错误信息到客户端，或者允许nginx使用error_page处理错误信息。注：静态文件不存在会返回404页面，但是php页面则返回空白页！fastcgi_cache_path /usr/local/nginx1.10/fastcgi_cachelevels=1:2 keys_zone=cache_fastcgi:128minactive=1d max_size=10g ：fastcgi_cache缓存目录，可以设置目录层级，比如1:2会生成16*256个子目录，cache_fastcgi是这个缓存空间的名字，cache是用多少内存（这样热门的内容nginx直接放内存，提高访问速度），inactive表示默认失效时间，如果缓存数据在失效时间内没有被访问,将被删除，max_size表示最多用多少硬盘空间。fastcgi_cache cache_fastcgi ：#表示开启FastCGI缓存并为其指定一个名称。开启缓存非常有用，可以有效降低CPU的负载，并且防止502的错误放生。cache_fastcgi为proxy_cache_path指令创建的缓存区名称。fastcgi_cache_valid 200 302 1h ：#用来指定应答代码的缓存时间，实例中的值表示将200和302应答缓存一小时，要和fastcgi_cache配合使用。fastcgi_cache_valid 301 1d ：将301应答缓存一天。fastcgi_cache_valid any 1m ：将其他应答缓存为1分钟。fastcgi_cache_min_uses 1 ：该指令用于设置经过多少次请求的相同URL将被缓存。fastcgi_cache_key http://$host$request_uri ：该指令用来设置web缓存的Key值,nginx根据Key值md5哈希存储.一般根据$host(域名)、$request_uri(请求的路径)等变量组合成proxy_cache_key 。fastcgi_pass  ：指定FastCGI服务器监听端口与地址，可以是本机或者其它。</code></pre><p>总结：</p><p>nginx的缓存功能有：proxy_cache / fastcgi_cache</p><p>proxy_cache的作用是缓存后端服务器的内容，可能是任何内容，包括静态的和动态。</p><p>fastcgi_cache的作用是缓存fastcgi生成的内容，很多情况是php生成的动态的内容。</p><p>proxy_cache缓存减少了nginx与后端通信的次数，节省了传输时间和后端宽带。</p><p>fastcgi_cache缓存减少了nginx与php的通信的次数，更减轻了php和数据库(mysql)的压力。</p><h3><span id="8-gzip-调优">8、gzip 调优</span></h3><p>使用gzip压缩功能，可能为我们节约带宽，加快传输速度，有更好的体验，也为我们节约成本，所以说这是一个重点。</p><p>Nginx启用压缩功能需要你来ngx_http_gzip_module模块，apache使用的是mod_deflate。</p><p>一般我们需要压缩的内容有：文本，js，html，css，对于图片，视频，flash什么的不压缩，同时也要注意，我们使用gzip的功能是需要消耗CPU的！</p><pre><code class="bash">gzip on;gzip_min_length 2k;gzip_buffers   4 32k;gzip_http_version 1.1;gzip_comp_level 6;gzip_typestext/plain text/css text/javascriptapplication/json application/javascript application/x-javascriptapplication/xml;gzip_vary on;gzip_proxied any;gzip on;   #开启压缩功能gzip_min_length 1k ：设置允许压缩的页面最小字节数，页面字节数从header头的Content-Length中获取，默认值是0，不管页面多大都进行压缩，建议设置成大于1K，如果小与1K可能会越压越大。gzip_buffers 4 32k ：压缩缓冲区大小，表示申请4个单位为32K的内存作为压缩结果流缓存，默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果。gzip_http_version 1.1 ：压缩版本，用于设置识别HTTP协议版本，默认是1.1，目前大部分浏览器已经支持GZIP解压，使用默认即可。gzip_comp_level 6 ：压缩比例，用来指定GZIP压缩比，1压缩比最小，处理速度最快，9压缩比最大，传输速度快，但是处理慢，也比较消耗CPU资源。gzip_types text/css text/xml application/javascript ：用来指定压缩的类型，‘text/html’类型总是会被压缩。默认值: gzip_types text/html (默认不对js/css文件进行压缩)压缩类型，匹配MIME型进行压缩；不能用通配符 text/*；text/html默认已经压缩 (无论是否指定)；设置哪压缩种文本文件可参考 conf/mime.types。gzip_vary on ：varyheader支持，改选项可以让前端的缓存服务器缓存经过GZIP压缩的页面，例如用Squid缓存经过nginx压缩的数据。</code></pre><h3><span id="9-expires-缓存调优">9、expires 缓存调优</span></h3><p>缓存，主要针对于图片，css，js等元素更改机会比较少的情况下使用，特别是图片，占用带宽大，我们完全可以设置图片在浏览器本地缓存365d，css，js，html可以缓存个10来天，这样用户第一次打开加载慢一点，第二次，就非常快了！缓存的时候，我们需要将需要缓存的拓展名列出来， Expires缓存配置在server字段里面。</p><pre><code class="bash">location ~* \.(ico|jpe?g|gif|png|bmp|swf|flv)$ {expires 30d;#log_not_found off;access_log off;}location ~* \.(js|css)$ {expires 7d;log_not_found off;access_log off;}注：log_not_found off;是否在error_log中记录不存在的错误。默认是。</code></pre><p>总结：</p><p>expire功能优点：</p><p>expires可以降低网站购买的带宽，节约成本；</p><p>同时提升用户访问体验；</p><p>减轻服务的压力，节约服务器成本，是web服务非常重要的功能。</p><p>expire功能缺点：</p><p>被缓存的页面或数据更新了，用户看到的可能还是旧的内容，反而影响用户体验。</p><p>解决办法：第一个缩短缓存时间，例如：1天，但不彻底，除非更新频率大于1天；第二个对缓存的对象改名。</p><p>网站不希望被缓存的内容：</p><p>网站流量统计工具；</p><p>更新频繁的文件（google的logo）。</p><h3><span id="10-防盗链">10、防盗链</span></h3><p>防止别人直接从你网站引用图片等链接，消耗了你的资源和网络流量，那么我们的解决办法由几种：</p><p>水印，品牌宣传，你的带宽，服务器足够；</p><p>防火墙，直接控制，前提是你知道IP来源；</p><p>防盗链策略下面的方法是直接给予404的错误提示。</p><pre><code class="bash">location ~*^.+\.(jpg|gif|png|swf|flv|wma|wmv|asf|mp3|mmf|zip|rar)$ {valid_referers noneblocked www.benet.com benet.com;if($invalid_referer) {  #return 302 http://www.benet.com/img/nolink.jpg;  return 404;  break;}access_log off;}</code></pre><p>参数可以使如下形式：</p><p>none  ：意思是不存在的Referer头(表示空的，也就是直接访问，比如直接在浏览器打开一个图片)。</p><p>blocked  ：意为根据防火墙伪装Referer头，如：“Referer:XXXXXXX”。</p><p>server_names  ：为一个或多个服务器的列表，0.5.33版本以后可以在名称中使用“*”通配符。</p><h3><span id="11-内核参数优化">11、内核参数优化</span></h3><p>fs.file-max = 999999：这个参数表示进程（比如一个worker进程）可以同时打开的最大句柄数，这个参数直线限制最大并发连接数，需根据实际情况配置。</p><p>net.ipv4.tcp_max_tw_buckets = 6000 ：这个参数表示操作系统允许TIME_WAIT套接字数量的最大值，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。该参数默认为180000，过多的TIME_WAIT套接字会使Web服务器变慢。注：主动关闭连接的服务端会产生TIME_WAIT状态的连接</p><pre><code class="bash">net.ipv4.ip_local_port_range = 1024 65000  ：允许系统打开的端口范围。net.ipv4.tcp_tw_recycle = 1 ：启用timewait快速回收。net.ipv4.tcp_tw_reuse = 1 ：开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。这对于服务器来说很有意义，因为服务器上总会有大量TIME-WAIT状态的连接。net.ipv4.tcp_keepalive_time = 30：这个参数表示当keepalive启用时，TCP发送keepalive消息的频度。默认是2小时，若将其设置的小一些，可以更快地清理无效的连接。net.ipv4.tcp_syncookies = 1 ：开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理。net.core.somaxconn = 40960  ：web 应用中 listen 函数的 backlog 默认会给我们内核参数的。net.core.somaxconn  ：限制到128，而nginx定义的NGX_LISTEN_BACKLOG 默认为511，所以有必要调整这个值。注：对于一个TCP连接，Server与Client需要通过三次握手来建立网络连接.当三次握手成功后,我们可以看到端口的状态由LISTEN转变为ESTABLISHED,接着这条链路上就可以开始传送数据了.每一个处于监听(Listen)状态的端口,都有自己的监听队列.监听队列的长度与如somaxconn参数和使用该端口的程序中listen()函数有关。somaxconn定义了系统中每一个端口最大的监听队列的长度,这是个全局的参数,默认值为128，对于一个经常处理新连接的高负载 web服务环境来说，默认的 128 太小了。大多数环境这个值建议增加到 1024 或者更多。大的侦听队列对防止拒绝服务 DoS 攻击也会有所帮助。net.core.netdev_max_backlog = 262144  ：每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。net.ipv4.tcp_max_syn_backlog = 262144 ：这个参数标示TCP三次握手建立阶段接受SYN请求队列的最大长度，默认为1024，将其设置得大一些可以使出现Nginx繁忙来不及accept新连接的情况时，Linux不至于丢失客户端发起的连接请求。net.ipv4.tcp_rmem = 10240 87380 12582912 ：这个参数定义了TCP接受缓存（用于TCP接受滑动窗口）的最小值、默认值、最大值。net.ipv4.tcp_wmem = 10240 87380 12582912：这个参数定义了TCP发送缓存（用于TCP发送滑动窗口）的最小值、默认值、最大值。net.core.rmem_default = 6291456：这个参数表示内核套接字接受缓存区默认的大小。net.core.wmem_default = 6291456：这个参数表示内核套接字发送缓存区默认的大小。net.core.rmem_max = 12582912：这个参数表示内核套接字接受缓存区的最大大小。net.core.wmem_max = 12582912：这个参数表示内核套接字发送缓存区的最大大小。net.ipv4.tcp_syncookies = 1：该参数与性能无关，用于解决TCP的SYN攻击。</code></pre><p>下面贴一个完整的内核优化设置：</p><pre><code class="bash">fs.file-max = 999999net.ipv4.ip_forward = 0net.ipv4.conf.default.rp_filter = 1net.ipv4.conf.default.accept_source_route = 0kernel.sysrq = 0kernel.core_uses_pid = 1net.ipv4.tcp_syncookies = 1kernel.msgmnb = 65536kernel.msgmax = 65536kernel.shmmax = 68719476736kernel.shmall = 4294967296net.ipv4.tcp_max_tw_buckets = 6000net.ipv4.tcp_sack = 1net.ipv4.tcp_window_scaling = 1net.ipv4.tcp_rmem = 10240 87380 12582912net.ipv4.tcp_wmem = 10240 87380 12582912net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.core.netdev_max_backlog = 262144net.core.somaxconn = 40960net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_timestamps = 0net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_mem = 94500000 915000000 927000000net.ipv4.tcp_fin_timeout = 1net.ipv4.tcp_keepalive_time = 30net.ipv4.ip_local_port_range = 1024 65000执行sysctl  -p使内核修改生效。</code></pre><h3><span id="12-关于系统连接数的优化">12、关于系统连接数的优化</span></h3><pre><code class="bash"># linux 默认值 open files为1024。查看当前系统值：ulimit -n1024# 说明server只允许同时打开1024个文件。</code></pre><p>使用ulimit -a 可以查看当前系统的所有限制值，使用ulimit -n 可以查看当前的最大打开文件数。</p><p>新装的linux 默认只有1024 ，当作负载较大的服务器时，很容易遇到error: too many open files。因此，需要将其改大，在/etc/security/limits.conf最后增加：</p><pre><code class="bash">*               soft    nofile           65535*               hard   nofile           65535*               soft    noproc         65535*               hard   noproc         65535</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群-负载均衡</title>
      <link href="/2020/06/20/%E9%9B%86%E7%BE%A4-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2020/06/20/%E9%9B%86%E7%BE%A4-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s实战</title>
      <link href="/2020/06/20/k8s%E5%AE%9E%E6%88%98/"/>
      <url>/2020/06/20/k8s%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库运维</title>
      <link href="/2020/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E7%BB%B4/"/>
      <url>/2020/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux运维常用命令</title>
      <link href="/2020/06/20/linux%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/20/linux%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1><span id="linux-常用命令">linux 常用命令</span></h1><pre><code class="bash">$ hexo new "My New Post"</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/19/hello-world/"/>
      <url>/2020/06/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3><span id="run-server">Run server</span></h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
