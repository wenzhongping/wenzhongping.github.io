<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IDC网络运维</title>
      <link href="/2020/06/22/IDC%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/"/>
      <url>/2020/06/22/IDC%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h1><span id="网络运维">网络运维</span></h1><h2><span id="第一章-路由交换">第一章  路由交换</span></h2><h3><span id="11-华为交换机配置">1.1 华为交换机配置</span></h3><h4><span id="交换机堆叠">交换机堆叠</span></h4><pre><code class="bash"># 先把所有端口down&lt;HUAWEI&gt; system-view[~HUAWEI] stack[~HUAWEI-stack] stack member 1 renumber 1 inherit-config      //配置堆叠成员ID--默认为1，一般住堆叠设备不改，只需改变优先级Warning: The stack configuration of member ID 1 will be inherited to member ID 2 after the device resets. Continue? [Y/N]: y[*HUAWEI-stack] stack member 1 priority 150      //配置堆叠优先级（默认为100，修改更高确认主从）[*HUAWEI-stack] stack member 1 domain 10       //配置堆叠域编号[*HUAWEI-stack] quit[*HUAWEI] commit                                                //提交配置&lt;HUAWEI&gt;save                                                    //保存配置&lt;HUAWEI&gt;reboot                                               //重启设备[~HUAWEI] interface stack-port 1/1      //创建堆叠逻辑端口[*HUAWEI-Stack-Port1/1] port member-group interface 100ge 1/0/7 to 1/0/8[*HUAWEI-Stack-Port1/1] quit第二台设备[~HUAWEI-stack] stack member 1 renumber 2 inherit-config      //配置堆叠成员ID--默认为1，备份堆叠设备需修改[*HUAWEI] commit[~HUAWEI] quit&lt;HUAWEI&gt; save      //保存配置Warning: The current configuration will be written to the device. Continue? [Y/N]: y&lt;HUAWEI&gt; reboot      //重启设备Warning: The system will reboot. Continue? [Y/N]: y[*HUAWEI-stack] stack member 2 domain 10       //配置堆叠域编号，因SwitchB尚未重启，当前堆叠成员ID还是1，所以此时仍使用member 1来进行堆叠配置。如果重启则使用2[*HUAWEI] interface stack-port 2/2[*HUAWEI-Stack-Port1/2] port member-group interface 100ge 2/0/7 to 2/0/8 ，--》修改堆叠成员id后，接口1/0/7默认变为2/0/7 日志服务器[*HUAWEI-Stack-Port1/2] quit[*HUAWEI] commit[~HUAWEI] quit&lt;HUAWEI&gt; save      //保存配置Warning: The current configuration will be written to the device. Continue? [Y/N]: y&lt;HUAWEI&gt; reboot      //重启设备Warning: The system will reboot. Continue? [Y/N]: y# 第三步：等都重启好了，打开堆叠的端口，插上堆叠线</code></pre><p>查看光功率</p><pre><code class="bash">dis transceiver interface XGigabitEthernet 0/1/1 verbose </code></pre><p>查看所有配置</p><pre><code class="bash">sysdis cu</code></pre><p>把100G口一分四</p><pre><code class="bash">port split dimension interface 100GE1/0/7 to 100GE1/0/20 split-type 4*25GE重启</code></pre><p>配置三层口并配置ip</p><pre><code class="bash">int 100GE1/0/1undo portswitchcommitdescription to SWip address 10.1.1.10 255.255.255.252commit</code></pre><p>配置静态路由</p><pre><code class="bash">ip route-static 10.1.1.0 255.255.255.0 100GE1/0/1 172.22.2.2 description to S5560-test</code></pre><p>保存配置</p><pre><code class="bash">commitsave</code></pre><p>清空交换机配置**</p><pre><code class="bash"># 1.启动交换机，按Ctrl+B进入交换机的BootRom菜单...7. skip current configuration ...# 选择 “7” 回车后选择“Y”# 选择 “0” 重新启动交换机此时交换机会以出厂设置进入没密码# 进入到交换机直接输入save 保存空配置，替换以前的配置文件# 输入reboot重启交换机，再选择“7”此时选择“N”，重启后再配置即可</code></pre><h3><span id="12-华三交换机配置">1.2 华三交换机配置</span></h3><h4><span id="交换机堆叠">交换机堆叠</span></h4><pre><code class="bash"># 先把所有端口down掉第一台：irf member 1 pri 26saveint range ten 1/0/29 to ten 1/0/32shutquirf-port 1/1port group interface Ten-GigabitEthernet1/0/29port group interface Ten-GigabitEthernet1/0/30 port group interface Ten-GigabitEthernet1/0/31 port group interface Ten-GigabitEthernet1/0/32quint range ten 1/0/29 to ten 1/0/32undo shutqusave irf-port-config active 第二台：irf member 1 re 2saverebootirf member 2 pri 10saveint range ten 2/0/29 to ten 2/0/32shutquirf-port 2/2port group interface Ten-GigabitEthernet2/0/29port group interface Ten-GigabitEthernet2/0/30 port group interface Ten-GigabitEthernet2/0/31 port group interface Ten-GigabitEthernet2/0/32quint range ten 2/0/29 to ten 2/0/32undo shutqusave irf-port-config active 第三步：插上堆叠线，备机自动重启，重启后重新save f第四步：在主机dis int 查看端口状态，是否能看到2机端口</code></pre><h2><span id="第二章-波分传输">第二章 波分传输</span></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2020/06/22/nginx/"/>
      <url>/2020/06/22/nginx/</url>
      
        <content type="html"><![CDATA[<h1><span id="nginx从入门到精通">Nginx从入门到精通</span></h1><h2><span id="第一章-nginx简介以及安装">第一章  Nginx简介以及安装</span></h2><h3><span id="11-nginx由来">1.1 Nginx由来</span></h3><p>Nginx是一个web应用及反向代理工具，由一名俄罗斯程序员(Igor)发明的。NGINX是一个免费的，开源的高性能HTTP服务器和反向代理，以及IMAP / POP3代理服务器。 NGINX以其高性能，稳定性，丰富的功能集，简单的配置和低资源消耗而闻名。</p><h3><span id="12-nginx特点">1.2 Nginx特点</span></h3><p>主要有三大应用场景：</p><ul><li>静态资源服务 （web静态网页）</li><li>反向代理服务（缓存，负载均衡）</li><li>API服务（OpenResty）</li></ul><h3><span id="13-nginx优势">1.3 Nginx优势</span></h3><ul><li><p>更快，单次请求更快，高峰期也更快</p></li><li><p>高扩展性，极具扩展性，它由多个不同功能、不同层次、不同类型且耦合度极高的模块组成，这种低耦合的设计，造就了它庞大的第三方模块</p></li><li><p>高可靠性，每个worker进程相对独立，master进程在某个worker进程出错时能迅速拉起新的worker进程nginx的可靠性来源于其核心框架代码的优秀设计、模块设计的简单性。</p></li><li><p>低内存消耗，一般情况下10000个非活跃的keep-alive连接仅消耗2.5M的内存</p></li><li><p>单机支持10万以上的并发连接</p></li><li><p>热部署</p></li></ul><h3><span id="14-nginx安装centos">1.4 Nginx安装(centos)</span></h3><p>（1）直接通过yum安装</p><pre><code class="bash">yum install -y  nginx</code></pre><p>（2）通过编译安装</p><pre><code class="bash"># 更换阿里cento7的yum源（可选）yum list wget# 若没有安装wgetyum -y install wget# 首先备份原版/etc/yum.repos.d/CentOS-Base.repocd /etc/yum.repos.d mv CentOS-Base.repo CentOS-Base.repo.bak # 下载阿里yum源 wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo #运行yum makecache生成缓存 yum clean allyum makecache# 安装nginx依赖yum -y install gcc gcc-c++ autoconf automake make yum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel# 添加www用户groupadd -f wwwuseradd -g www www# 创建一个目录并切换mkdir nginxcd nginx# 下载nginxwget http://nginx.org/download/nginx-1.18.0.tar.gz# 解压tar -zxvf nginx-1.18.0.tar.gz# 配置nginxcd nginx-1.18.0# 安装依赖yum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel# 编译安装./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-stream --with-http_gzip_static_module --with-http_sub_module --with-http_v2_module</code></pre><img src="/2020/06/22/nginx/image-20200620224324492.png" class title="image-20200620224324492"><pre><code class="bash"># 出现以上可以开始编译安装make &amp;&amp; make install</code></pre><p>安装成功，刚刚通过./configure –prefix=/usr/local/nginx指定安装在/usr/local/nginx</p><pre><code class="bash">#查看启动情况ps -ef|grep nginx#查看是否启动成功curl 127.0.0.1#查看端口情况lsof -i :80COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEnginx   25363 root    6u  IPv4  73747      0t0  TCP *:http (LISTEN)nginx   25365  www    6u  IPv4  73747      0t0  TCP *:http (LISTEN)</code></pre><p>添加到系统环境变量</p><pre><code class="bash">vim /lib/systemd/system/nginx.service# 加入如下内容[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.targetvim /etc/profile # 加入以下内容export NGINX_HOME=/usr/local/nginxexport PATH=$PATH:$NGINX_HOME/sbin# 执行source /etc/profile</code></pre><pre><code class="bash">#启动nginx服务systemctl start nginx# 开机自启systemctl enable nginx#快速停止服务nginx -s stop# 优雅退出nginx  -s quit#检查配置文件nginx -t#重新加载配置nginx -s reload # 查看版本nginx -v</code></pre><h2><span id="第二章-常见nginx配置">第二章 常见Nginx配置</span></h2><h3><span id="21-nginx日志">2.1 nginx日志</span></h3><p>（1）access log配置</p><pre><code class="bash">access_log /var/log/access_log.gz combined gzip flush=5m;# 指定外部log日志服务器access_log syslog:server=192.168.1.10 debug;# /var/log/access_log.gz 存放日志的路径，默认是logs/access.log# gzip 压缩日志# flush=5m 5分钟写入硬盘一次# 使用默认combined格式记录日志</code></pre><p>(2) 日志切割</p><pre><code class="bash"># 备份之前日志mv access_log.log access_log.back.log# 切割日志nginx -s reopen</code></pre><h3><span id="22-热部署">2.2 热部署</span></h3><p>热升级：</p><pre><code class="bash"># 1.备份原执行文件nginx 为nginx.oldmv /usr/local/nginx/sbin/nginx  /usr/local/nginx/sbin/nginx.old# 2.将新编译好的nginx执行文件拷过来# 下载新版本并编译安装过程参考1.4，安装目录不能与旧版本路径一样cp /usr/local/nginx-19/sbin/nginx  /usr/local/nginx/sbin/nginx# 3.向nginx主进程发送USR2 信号，通知nginx要对它进行升级ps -ef  | grep nginx</code></pre><img src="/2020/06/22/nginx/image-20200621163132648.png" class title="image-20200621163132648"><pre><code class="bash">#  向老进程发送USR2信号，告诉老进程升级 kill -USR2 6579 # 向老进程发送退出老work信号  kill -WINCH 6579 # 确定没问题再quit 老进程（6579进程） kill -QUIT 6579 ps -ef  | grep nginx #查看版本 nginx -v</code></pre><img src="/2020/06/22/nginx/image-20200621163952054.png" class title="image-20200621163952054"><p>回滚操作</p><pre><code class="bash"># 1.恢复旧的二进制文件mv /usr/local/nginx/sbin/nginx.old  /usr/local/nginx/sbin/nginx# 2.退出新版本nginx进程kill -HUP 19857kill -QUIT 19857# 查看版本nginx -v# 指定配置文件为旧版本所用配置文件nginx -c /usr/local/nginx/conf/nginx.conf# 重新加载nginx -s reload</code></pre><h3><span id="23-web应用">2.3 web应用</span></h3><p>nginx.conf配置中隐藏版本号</p><pre><code class="bash"> # 隐藏版本号     server_tokens off;</code></pre><p>进入nginx配置文件夹</p><img src="/2020/06/22/nginx/image-20200621174446530.png" class title="image-20200621174446530"><p>主要配置在nginx.conf,一般不去修改此文件，我们可以再新建一个文件夹用于存放后续http模块配置，把该文件夹引入到nginx.conf配置文件中的http体内</p><pre><code class="bash">mkdir conf.d# 在nginx.conf中引入配置文件vim nginx.confinclude  /usr/local/nginx/conf/conf.d/*.conf:wq</code></pre><pre><code class="bash">#  新建一个html建测试页面touch /usr/local/nginx/www/index.htmlecho "hello word" &gt;&gt; /usr/local/nginx/www/index.html# 进入/usr/local/nginx/conf/conf.d新增配置文件cd /usr/local/nginx/conf/conf.dvim www.test.confserver {    listen      80;    # 若有域名则写域名，可以根据域名来转发到不同页面    server_name  localhost;# 访问日志配置    access_log  /var/log/index.access.log  main;# 网页文件所在路径    root   /usr/local/nginx/www/;# 访问/目录时显示index.html页面    location / {          index  index.html index.htm;    }    }# 测试curl 127.0.0.1:8080</code></pre><h4><span id="root-和-alias-的区别">root   和 alias 的区别:</span></h4><p>(1)</p><pre><code class="bash">location /images/ {       root "/app/webroot"}访问： http://www.test.com/images/a.jpg  相当于文件系统路径 /app/webroot/images/a.jpg </code></pre><p>(2)</p><pre><code class="bash">location  /images/ {      alias  "/www/pictures/"; }访问： http://www.test.com/images/a.jpg  相当于文件系统路径/www/pictures/a.jpg </code></pre><h4><span id="https-配置-以及访问http强制跳转到-https">https 配置 以及访问http强制跳转到 https</span></h4><p>https的配置</p><pre><code class="bash"># 若有阿里云域名可以免费生成https证书# 把生成好的证书下载并解压到指定目录# 在之前配置的基础上新增监听443端口cd /usr/local/nginx/conf/conf.dvim www.test.confserver {    listen      80;    # 若有域名则写域名，可以根据域名来转发到不同页面    server_name  localhost;# 访问日志配置    access_log  /var/log/index.access.log  main;# 网页文件所在路径    root   /usr/local/nginx/www/;    # 新增监听443端口配置listen 443 ssl;   #SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。  #/etc/nginx/key/4094309_www.test.pem为证书所在目录。  ssl_certificate /etc/nginx/key/4094309_www.test.com.pem; #/etc/nginx/key/4094309_www.test.com.key为key所在目录ssl_certificate_key /etc/nginx/key/4094309_www.test.com.key;  ssl_session_timeout 5m;ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件。ssl_protocols TLSv1 TLSv1.1 TLSv1.2;   #使用该协议进行配置。ssl_prefer_server_ciphers on;# 访问/目录时显示index.html页面    location / {          index  index.html index.htm;    }  # 客户端访问http强制跳转到https  if ($ssl_protocol = "") { return 301 https://$host$request_uri; }   }</code></pre><h5><span id="正则匹配">正则匹配</span></h5><h6><span id="元字符">元字符</span></h6><ul><li>. 匹配除换行符以外的任意字符</li><li>\w 匹配字母或数字或下划线或汉字</li><li>\s 匹配任意的空白符</li><li>\d 匹配数字</li><li>^ 匹配字符串开始</li><li>$匹配字符串结束</li></ul><h6><span id="重复">重复</span></h6><ul><li>“*”重复零次或更多次</li><li>“+”重复一次或更多次</li><li>“？”重复零次或一次</li><li>“{n}”重复n次</li><li>“{n,}”重复n或更多次</li><li>“{n,m}”重复n到m次</li></ul><p><strong>location的用法</strong></p><ul><li>以 = 开头，表示精确匹配；如只匹配根目录结尾的请求，后面不能带任何字符串。</li><li>以^~ 开头，表示uri以某个常规字符串开头，不是正则匹配</li><li>以~ 开头，表示区分大小写的正则匹配;</li><li>以~* 开头，表示不区分大小写的正则匹配</li><li>以/ 开头，通用匹配, 如果没有其它匹配,任何请求都会匹配到</li></ul><p>比较常用的location匹配</p><pre><code class="bash">#uri包含/static即可匹配中location ^~ /static/ {root /webroot/static/;}# uri以.(gif|jpg|jpeg|png|css|js|ico)结尾location ~* .(gif|jpg|jpeg|png|css|js|ico)$ {root /webroot/res/;}# 匹配全部location  ~.*^ {root /webroot/res/;}</code></pre><p>防盗链技术</p><p>简单有效的防盗链手段：referer模块</p><p>场景：</p><p>某网站通过url引用了你的页面，当用户在浏览器上点击 url时，http请求的头部中会通过 referer头部，将该网站当前页面的url带上，告诉服务器本次请求 是 由这个页面发起的</p><pre><code class="bash"># referer模块指令# invalid_referer 允许访问时变量为空 ，不允许访问时变量值为1# 例子：常见的图片视频防盗链location ~* .(gif|jpg|png|swf|flv)$ {# 通过浏览器直接打开会有referer信息，也就是valid_referers值为1# none 代表没有referer#  blocked 代表有referer但是被防火墙或者是代理给去除了# www.wosoquan.com wosoquan.com  nginx会通过正则匹配，匹配到以上字符串值为0，否则为1valid_referers none blocked www.test.com test.com ;if ($invalid_referer) {# 若用户直接盗链接打开，则跳转至http://www.test.com/retrun.htmlrewrite ^/ http://www.test.com/retrun.html;#return 403;}}</code></pre><p><code>proxy_set_header</code>和<code>add_header</code>的区别</p><p>区别：<code>proxy_set_header</code>是<code>Nginx</code>设置请求头信息给上游服务器，<code>add_header</code>是<code>Nginx</code>设置响应头信息给浏览器。</p><ul><li><p>proxy_set_header</p><p>假如<code>Nginx</code>请求上游服务器时，添加额外的请求头，就需要使用proxy_set_header</p><p>例如：<code>proxy_set_header X-Request-URI $scheme://$host/$uri;</code></p></li><li><p>add_header</p><p><code>Nginx</code>响应数据时，要告诉浏览器一些头信息，就要使用<code>add_header</code>。例如跨域访问</p></li></ul><p>新增http头部信息</p><pre><code class="bash">server {#添加一个自定义头部信息add_header  server:test;# 插入X-Forward-For到 下游服务器proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;#插入X-Real-IP远端真实ipproxy_set_header X-Real-IP $remote_addr;}</code></pre><p>X-Forward-For 与X-Real-IP区别</p><ul><li>HTTP 头部X-Forward-For用户传递IP</li><li>HTTP 头X-Real-IP用户传递用户 IP</li></ul><img src="/2020/06/22/nginx/image-20200622141513297.png" class title="image-20200622141513297"><h3><span id="24反向代理负载均衡">2.4反向代理负载均衡</span></h3><p>如何理解反向代理？<br>Nginx是反向代理服务器，我们可以从下面的图来理解为什么是反向代理。以Nginx为中心，数据的流向是从Server到Nginx再到Client，注意我说的是数据（响应数据），而不是请求。我们都知道水流一定是从上游流到下游，所以给Server一个别称上游服务器，当然这个别称并不是我定义的。</p><img src="/2020/06/22/nginx/image-20200622135224719.png" class title="image-20200622135224719"><h4><span id="241-七层反向代理">2.4.1 七层反向代理</span></h4><p>负载均衡</p><pre><code class="bash">http {#新增上游服务器组upstream local {server 127.0.0.1:8080 weight 10 max_fails 3 fail_timeout 60 max_conns 3000 slow_start 30 ;server 127.0.0.1:8081 weight 20 max_fails 3 fail_timeout 60 max_conns 3000 slow_start 30 ;}server {listen 80 ;location / {#local为上面定义的上游服务器组名称proxy_pass http://local;}}}</code></pre><ul><li>Server      反向服务地址和端口</li><li>weight      权重，默认为1.weight越大权重越大</li><li>max_fails    失败次数，默认为1.超过最大次数主机被踢出</li><li>fail_timeout 踢出后重新探测时间 </li><li>backup 备用服务，主机宕机请求backup机器响应</li><li>max_conns 最大连接次数 默认为0 限制同时连接到单个服务器的最大连接数</li><li>slow_start 节点恢复时间  服务器权重从0恢复到标准的时间，默认为0，相当于缓慢启动</li></ul><p>Proxy_next_upstream</p><p>当上游返回失败的时候,我们是有些处理方法的，这个处理方法就是通过proxy_next_upstream这么一个指令来控制的。当然了该指令能够生效的前提是我们没有向客户端发送一个字节，即没有向客户端发送任何的内容，只要向客户端发送了一个字节了，说明上游服务已经生效了，那么我们就不能再选择一个新的上游服务了。所以它是在接收到请求并且在转发一个字节之前，nginx判定为错误，那么这个功能才能够生效。</p><pre><code class="bash">Syntax: proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 |http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...;Default: proxy_next_upstream error timeout;Context: http, server, locationerror:nginx与上游建立连接，读取响应发送请求等等这些过程当中出现错误，那么error都可以满足这样一个场景，这个错误指的是网络错误，比如TCP层等。timeout:超时，有connect timeout，read timeout，write timeout。那么配置了timeout可以命中这些场景，当命中这些场景可以重选上游服务。#监听到下错误时proxy_next_upstream生效（二选一） server{ proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504  non_idemponent; # 监听到下游服务器宕机后生效（二选一） # proxy_next_upstream  off ;</code></pre><p>proxy_intercept_errors 拦截上游失败响应</p><p>proxy_intercept_errors 当上游服务器响应头回来后，可以根据响应状态码的值进行拦截错误处理，与error_page 指令相互结合。用在访问上游服务器出现错误的情况下。</p><pre><code class="bash">server {location / {prxxy_intercept_errors on;error_page 500 /test.html;}}</code></pre><h4><span id="242-四层反向代理">2.4.2 四层反向代理</span></h4><pre><code class="bash">stream {upstream test  {server 127.0.0.1:8082 ;server 127.0.0.1:8083;}server {listen 13389 ;location / {#test为上面定义的上游服务器组名称proxy_pass http://test;}}}</code></pre><h3><span id="25-缓存">2.5 缓存</span></h3><pre><code class="bash"># nginx缓存空间配置，该配置定义在nginx配置文件的http模块server上方即可proxy_cache_path /etc/nginx/cachefiles levels=1:2 keys_zone=cache:10m max_size=100m inactive=60m use_temp_path=off;</code></pre><ul><li><p>proxy cache_path 缓存内容存放的目录文件</p></li><li><p>levels=1:2 Nginx为将要缓存的资源生成的key为f4cd0fbc769e94925ec5540b6a4136d0，那么key的最后一位0，以及倒数第2-3位6d作为两级的子目录，也就是该资源最终会被缓存到/path/to/cache/0/6d目录中</p></li><li><p>keys_zone 在共享内存中设置一块存储区域来存放缓存的key和metadata（类似使用次数），这样nginx可以快速判断一个request是否命中或者未命中缓存，1m可以存储8000个key，10m可以存储80000个key</p></li><li><p>max_size最大cache空间，如果不指定，会使用掉所有disk space，当达到配额后，会删除最少使用的cache文件</p></li><li><p>inactive未被访问文件在缓存中保留时间，本配置中如果60分钟未被访问则不论状态是否为expired，缓存控制程序会删掉文件</p></li><li><p>use_temp_path  #如果为off，则nginx会将缓存文件直接写入指定的cache文件中，而不是使用temp_path存储，官方建议为off，避免文件在不同文件系统中不必要的拷贝</p></li></ul><pre><code class="bash"># 在 location中应用缓存location / {# 设置上面定义的zoom名字proxy_cache cache# 设置缓存的Key值proxy_cache_key $scheme$proxy_host$request_uri; # cache记录保存时间为1天 proxy_cache_valid any 1d;# 设置绕过缓存的请求url，即url中包含该配置的值，则该请求不从缓存中获取数据，非必须配置proxy_cache_bypass $arg_noCache;#设置当这两个参数值为true时，不缓存proxy_cache_bypass $cookie_nocache $arg_nocache;# 此处是托底配置，旧的总比出错强，当nginx请求后台服务器报错的时候，如果返回配置的错误响应码，nginx则直接取缓存文件中的旧数据返回给用户proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;# 缓存并发锁，当nginx缓存没有命中的时候只有一个请求回源后端服务器请求数据，其他请求会等待proxy_cache_lock on;#等待锁超时时间设置proxy_cache_lock_timeout 1s;# proxy_cache_revalidate命令被启用，NGINX检测得知当前的缓存内容依然有效（If-Modified-Since或者If-None-Match）proxy_cache_revalidate on;#允许在后台发送子请求来更新过期的缓存文件proxy_cache_background_update on;#指定该虚拟服务器下什么类型的HTTP方法可以被缓存proxy_cache_methods GET HEAD;#设置某内容被N次请求后，Nginx缓存该内容。proxy_cache_min_uses 1;# 强制缓存proxy_ignore_headers X-Accel-Expires Expires Cache-Control;# 插入头部信息查看缓存状态 add_header X-Cache-Status $upstream_cache_status;}</code></pre><h3><span id="26-分块缓存技术">2.6 分块缓存技术</span></h3><p>ngx_http_slice_filter_module模块默认没有编译到Nginx程序中，需要编译时添加–with-http_slice_module选项</p><p>Nginx的slice模块可以将一个请求分解成多个子请求，每个子请求返回响应内容的一个片段，让大文件的缓存更有效率。</p><pre><code class="bash">location / {    slice             1m;    proxy_cache       cache;    proxy_cache_key   $uri$is_args$args$slice_range;    proxy_set_header  Range $slice_range;    proxy_cache_valid 200 206 1h;    proxy_pass        http://127.0.0.1:80;}</code></pre><p>slice指令设置分片的大小为1m。 这里使用了proxy_set_header指令，在取源时的HTTP请求中添加了Range头部，向源服务器请求文件的一部分，而不是全部内容。在proxy_cache_key中添加slice_range变量这样可以分片缓存</p><h4><span id="slice_range变量">slice_range变量</span></h4><p>slice_range这个变量作用非常特殊，这个变量的值是当前需要向源服务器请求的分片，如果分片的大小为1m，那么最开始变量的值为<code>bytes=0-1048575</code>，通过配置文件中的<code>proxy_set_header Range $slice_range;</code>可以知道取源时请求的Range头部为<code>Range:bytes=0-1048575</code>，源服务器如果支持Range请求，便会返回响应的前1m字节，得到这个响应后slice_range变量的值变为<code>bytes=1048576-2097171</code> ，再次取源时便会取后1m字节，依次直到取得全部响应内容。</p><img src="/2020/06/22/nginx/image-20200622151506812.png" class title="image-20200622151506812"><h3><span id="25-rewrite详解">2.5 rewrite详解</span></h3><h4><span id="rewrite在if中的用法">rewrite在if中的用法</span></h4><p>格式：if (条件判断) { 具体的rewrite规则 }</p><pre><code class="bash">if条件判断语句由Nginx内置变量、逻辑判断符号和目标字符串三部分组成。其中，内置变量是Nginx固定的非自定义的变量，如，$request_method, $request_uri等。逻辑判断符号，有=, !=, ~, ~*, !~, !~*!表示相反的意思，~为匹配符号，它右侧为正则表达式，区分大小写，而~*为不区分大小写匹配。目标字符串可以是正则表达式，通常不用加引号，但表达式中有特殊符号时，比如空格、花括号、分号等，需要用单引号引起来。</code></pre><p><strong>示例1：当http请求方法为post时，返回403状态码</strong></p><pre><code class="bash">if ($request_method = POST){    return 403; }</code></pre><p><strong>示例2：通过浏览器标识匹配关键字，禁止IE浏览器访问</strong></p><pre><code class="bash">if ($http_user_agent ~* MSIE) {    return 403;}</code></pre><p>限制多个浏览器：</p><pre><code class="bash">if ($http_user_agent ~* "MSIE|firefox|Chrome"){    return 403;}</code></pre><p><strong>示例3：当请求的文件不存在时，进行重定向或return状态码等处理操作</strong></p><pre><code class="bash">if(!-f $request_filename){    rewrite 语句;}</code></pre><p><strong>示例4：判断uri中某个参数的内容</strong></p><pre><code class="bash"># \d表示数字，{6,8}表示数字出现的次数是6到8次，当uri中gid参数的值包含6-8个数字那么执行rewrite语句if($request_uri ~* 'gid=\d{6,8}/') {    rewrite 语句;}</code></pre><h4><span id="rewrite中break和last的用法">rewrite中break和last的用法</span></h4><p>两个指令用法相同，但含义不同，需要放到rewrite规则的末尾，用来控制重写后的链接是否继续被nginx配置执行(主要是rewrite、return指令)。</p><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/wwwroot/test.com;    rewrite /1.html /2.html;    rewrite /2.html /3.html;}</code></pre><p>请求1.html文件时，会被重定向到2.html，然后被重定向到3.html，最后返回的文件为3.html</p><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/test.com;    rewrite /1.html /2.html break;    rewrite /2.html /3.html;}</code></pre><p>请求1.html文件时，会被重定向到2.html，然后直接返回2.html，break在此处的作用就是当匹配第一个rewrite指令成功时，不执行后面的rewrite指令</p><p><strong>示例2：当break后面还有location{}的情况</strong></p><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/test.com;    rewrite /1.html /2.html break;    rewrite /2.html /3.html;    location /2.html {        return 403;    }}</code></pre><p>请求1.html文件时，会返回403状态码，当1.html被重定向到2.html时，break不会匹配后面的rewrite规则，但条件2.html匹配location{}定义的文件2.html，所以会执行return 403</p><p>以上两个示例中，将break换成last效果一样</p><h5><span id="2break和last在location内部时">2.break和last在location{}内部时</span></h5><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/test.com;    location / {        rewrite /1.html /2.html;        rewrite /2.html /3.html;    }    location /2.html    {        rewrite /2.html /a.html;    }    location /3.html    {        rewrite /3.html /b.html;    }}</code></pre><p>请求1.html，会经过两次重定向到3.html，3.html又刚好匹配location /3.html{}，所以返回b.html，当请求2.html时，会直接返回a.html，因为location /2.html {} 更精准，优先匹配</p><p><strong>示例1：在rewrite后面添加break</strong></p><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/test.com;    location / {        rewrite /1.html /2.html break;        rewrite /2.html /3.html;    }    location /2.html    {        rewrite /2.html /a.html;    }    location /3.html    {        rewrite /3.html /b.html;    }}</code></pre><p>请求1.html，会返回2.html，不会返回a.html，当break再location {} 内部时，遇到break后，当前location{} 以及后面的location{} 的指令都不再执行</p><p><strong>示例2：在rewrite后面添加last</strong></p><pre><code class="bash">server{    listen 80;     server_name test.com;    root /data/test.com;    location / {        rewrite /1.html /2.html last;        rewrite /2.html /3.html;    }    location /2.html    {        rewrite /2.html /a.html;    }    location /3.html    {        rewrite /3.html /b.html;    }}</code></pre><p>请求1.html时，会返回a.html，在location {} 内部遇到last，当前location {}中剩下的指令不会再执行，但被重定向的url会重新匹配一遍location {}</p><p><strong>break和last用法总结</strong></p><p>1.当rewrite规则在location{}外，break和last作用一样，遇到break或last后，其后续的rewrite/return语句不再执行。但后续有location{}的话，还会近一步执行location{}里面的语句,前提是请求能匹配该location<br>2.当rewrite规则在location{}里，遇到break后，本location{}与其他location{}的所有rewrite/return规则都不再执行<br>3.当rewrite规则在location{}里，遇到last后，本location{}里后续rewrite/return规则不执行，但重写后的url再次从头匹配所有location</p><h4><span id="动静态请求分离跳转">动静态请求分离跳转</span></h4><pre><code class="bash">server{    listen 80;    server_name www.test.com;    location ~* .*\.(jpg|jpeg|gif|css|png|js)$    {        rewrite /(.*) http://img.test.com/$1 permanent;    }}</code></pre><h4><span id="http跳转https">http跳转https</span></h4><pre><code class="bash">server{    listen 80;    server_name www.test.com;    rewrite /(.*) https://www.test.com/$1 permanent;}</code></pre><h2><span id="第三章-nginx优化">第三章 Nginx优化</span></h2><h3><span id="1-nginx运行工作进程数量">1、Nginx运行工作进程数量</span></h3><p>Nginx运行工作进程个数一般设置CPU的核心或者核心数x2。如果不了解cpu的核数，可以top命令之后按1看出来，也可以查看/proc/cpuinfo文件 grep ^processor /proc/cpuinfo | wc -l</p><pre><code class="bash">[root@lx~]# vi/usr/local/nginx1.10/conf/nginx.confworker_processes 4;[root@lx~]# /usr/local/nginx1.10/sbin/nginx-s reload[root@lx~]# ps -aux | grep nginx |grep -v greproot 9834 0.0 0.0 47556 1948 ?     Ss 22:36 0:00 nginx: master processnginxwww 10135 0.0 0.0 50088 2004 ?       S   22:58 0:00 nginx: worker processwww 10136 0.0 0.0 50088 2004 ?       S   22:58 0:00 nginx: worker processwww 10137 0.0 0.0 50088 2004 ?       S   22:58 0:00 nginx: worker processwww 10138 0.0 0.0 50088 2004 ?       S   22:58 0:00 nginx: worker process</code></pre><h3><span id="2-nginx运行cpu亲和力">2、Nginx运行CPU亲和力</span></h3><p>比如4核配置：</p><p>worker_processes 4;<br>worker_cpu_affinity 0001 0010 0100 1000<br>比如8核配置：</p><p>worker_processes 8;<br>worker_cpu_affinity 00000001 00000010 00000100 0000100000010000 00100000 01000000 10000000;<br>worker_processes最多开启8个，8个以上性能提升不会再提升了，而且稳定性变得更低，所以8个进程够用了。</p><h3><span id="3-nginx最大打开文件数">3、Nginx最大打开文件数</span></h3><p>worker_rlimit_nofile 65535;<br>这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n的值保持一致。</p><p>注：文件资源限制的配置可以在/etc/security/limits.conf设置，针对root/user等各个用户或者*代表所有用户来设置。</p><ul><li>soft nofile   65535</li><li>hard nofile   65535<br>用户重新登录生效（ulimit -n）</li></ul><h3><span id="4-nginx事件处理模型">4、Nginx事件处理模型</span></h3><p>events {<br>  use epoll;<br>  worker_connections 65535;<br>  multi_accept on;<br>}<br>nginx采用epoll事件模型，处理效率高。</p><p>work_connections是单个worker进程允许客户端最大连接数，这个数值一般根据服务器性能和内存来制定，实际最大值就是worker进程数乘以work_connections。</p><p>实际我们填入一个65535，足够了，这些都算并发值，一个网站的并发达到这么大的数量，也算一个大站了！</p><p>multi_accept 告诉nginx收到一个新连接通知后接受尽可能多的连接，默认是on，设置为on后，多个worker按串行方式来处理连接，也就是一个连接只有一个worker被唤醒，其他的处于休眠状态，设置为off后，多个worker按并行方式来处理连接，也就是一个连接会唤醒所有的worker，直到连接分配完毕，没有取得连接的继续休眠。当你的服务器连接数不多时，开启这个参数会让负载有一定的降低，但是当服务器的吞吐量很大时，为了效率，可以关闭这个参数。</p><h3><span id="5-开启高效传输模式">5、开启高效传输模式</span></h3><pre><code class="bash">http {  include mime.types;  default_type application/octet-stream;  ……  sendfile on;  tcp_nopush on;  ……}</code></pre><p>Include mime.types ： 媒体类型,include 只是一个在当前文件中包含另一个文件内容的指令。</p><p>default_type application/octet-stream ：默认媒体类型足够。</p><ul><li><p>sendfile on：开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</p></li><li><p>tcp_nopush on：必须在sendfile开启模式才有效，防止网路阻塞，积极的减少网络报文段的数量（将响应头和正文的开始部分一起发送，而不一个接一个的发送。）</p></li></ul><h3><span id="6-连接超时时间">6、连接超时时间</span></h3><p>主要目的是保护服务器资源，CPU，内存，控制连接数，因为建立连接也是需要消耗资源的。</p><pre><code class="bash">keepalive_timeout 60;tcp_nodelay on;client_header_buffer_size 4k;open_file_cache max=102400 inactive=20s;open_file_cache_valid 30s;open_file_cache_min_uses 1;client_header_timeout 15;client_body_timeout 15;reset_timedout_connection on;send_timeout 15;server_tokens off;client_max_body_size 10m;keepalived_timeout ：客户端连接保持会话超时时间，超过这个时间，服务器断开这个链接。tcp_nodelay：也是防止网络阻塞，不过要包涵在keepalived参数才有效。client_header_buffer_size 4k：客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过 1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。open_file_cache max=102400 inactive=20s ：这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。open_file_cache_valid 30s：这个是指多长时间检查一次缓存的有效信息。open_file_cache_min_uses 1 ：open_file_cache指令中的inactive 参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive 时间内一次没被使用，它将被移除。client_header_timeout ： 设置请求头的超时时间。我们也可以把这个设置低些，如果超过这个时间没有发送任何数据，nginx将返回request time out的错误。client_body_timeout设置请求体的超时时间。我们也可以把这个设置低些，超过这个时间没有发送任何数据，和上面一样的错误提示。reset_timeout_connection ：告诉nginx关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间。send_timeout ：响应客户端超时时间，这个超时时间仅限于两个活动之间的时间，如果超过这个时间，客户端没有任何活动，nginx关闭连接。server_tokens ：并不会让nginx执行的速度更快，但它可以关闭在错误页面中的nginx版本数字，这样对于安全性是有好处的。client_max_body_size：上传文件大小限制。</code></pre><h3><span id="7-fastcgi-调优">7、fastcgi 调优</span></h3><pre><code class="bash">fastcgi_connect_timeout 600;fastcgi_send_timeout 600;fastcgi_read_timeout 600;fastcgi_buffer_size 64k;fastcgi_buffers 4 64k;fastcgi_busy_buffers_size 128k;fastcgi_temp_file_write_size 128k;fastcgi_temp_path/usr/local/nginx1.10/nginx_tmp;fastcgi_intercept_errors on;fastcgi_cache_path/usr/local/nginx1.10/fastcgi_cache levels=1:2 keys_zone=cache_fastcgi:128minactive=1d max_size=10g;fastcgi_connect_timeout 600 ：指定连接到后端FastCGI的超时时间。fastcgi_send_timeout 600 ：向FastCGI传送请求的超时时间。fastcgi_read_timeout 600 ：指定接收FastCGI应答的超时时间。fastcgi_buffer_size 64k ：指定读取FastCGI应答第一部分需要用多大的缓冲区，默认的缓冲区大小为。fastcgi_buffers指令中的每块大小，可以将这个值设置更小。fastcgi_buffers 4 64k ：指定本地需要用多少和多大的缓冲区来缓冲FastCGI的应答请求，如果一个php脚本所产生的页面大小为256KB，那么会分配4个64KB的缓冲区来缓存，如果页面大小大于256KB，那么大于256KB的部分会缓存到fastcgi_temp_path指定的路径中，但是这并不是好方法，因为内存中的数据处理速度要快于磁盘。一般这个值应该为站点中php脚本所产生的页面大小的中间值，如果站点大部分脚本所产生的页面大小为256KB，那么可以把这个值设置为“8 32K”、“4 64k”等。fastcgi_busy_buffers_size 128k ：建议设置为fastcgi_buffers的两倍，繁忙时候的buffer。fastcgi_temp_file_write_size 128k ：在写入fastcgi_temp_path时将用多大的数据块，默认值是fastcgi_buffers的两倍，该数值设置小时若负载上来时可能报502BadGateway。fastcgi_temp_path  ：缓存临时目录。fastcgi_intercept_errors on ：这个指令指定是否传递4xx和5xx错误信息到客户端，或者允许nginx使用error_page处理错误信息。注：静态文件不存在会返回404页面，但是php页面则返回空白页！fastcgi_cache_path /usr/local/nginx1.10/fastcgi_cachelevels=1:2 keys_zone=cache_fastcgi:128minactive=1d max_size=10g ：fastcgi_cache缓存目录，可以设置目录层级，比如1:2会生成16*256个子目录，cache_fastcgi是这个缓存空间的名字，cache是用多少内存（这样热门的内容nginx直接放内存，提高访问速度），inactive表示默认失效时间，如果缓存数据在失效时间内没有被访问,将被删除，max_size表示最多用多少硬盘空间。fastcgi_cache cache_fastcgi ：#表示开启FastCGI缓存并为其指定一个名称。开启缓存非常有用，可以有效降低CPU的负载，并且防止502的错误放生。cache_fastcgi为proxy_cache_path指令创建的缓存区名称。fastcgi_cache_valid 200 302 1h ：#用来指定应答代码的缓存时间，实例中的值表示将200和302应答缓存一小时，要和fastcgi_cache配合使用。fastcgi_cache_valid 301 1d ：将301应答缓存一天。fastcgi_cache_valid any 1m ：将其他应答缓存为1分钟。fastcgi_cache_min_uses 1 ：该指令用于设置经过多少次请求的相同URL将被缓存。fastcgi_cache_key http://$host$request_uri ：该指令用来设置web缓存的Key值,nginx根据Key值md5哈希存储.一般根据$host(域名)、$request_uri(请求的路径)等变量组合成proxy_cache_key 。fastcgi_pass  ：指定FastCGI服务器监听端口与地址，可以是本机或者其它。</code></pre><p>总结：</p><p>nginx的缓存功能有：proxy_cache / fastcgi_cache</p><p>proxy_cache的作用是缓存后端服务器的内容，可能是任何内容，包括静态的和动态。</p><p>fastcgi_cache的作用是缓存fastcgi生成的内容，很多情况是php生成的动态的内容。</p><p>proxy_cache缓存减少了nginx与后端通信的次数，节省了传输时间和后端宽带。</p><p>fastcgi_cache缓存减少了nginx与php的通信的次数，更减轻了php和数据库(mysql)的压力。</p><h3><span id="8-gzip-调优">8、gzip 调优</span></h3><p>使用gzip压缩功能，可能为我们节约带宽，加快传输速度，有更好的体验，也为我们节约成本，所以说这是一个重点。</p><p>Nginx启用压缩功能需要你来ngx_http_gzip_module模块，apache使用的是mod_deflate。</p><p>一般我们需要压缩的内容有：文本，js，html，css，对于图片，视频，flash什么的不压缩，同时也要注意，我们使用gzip的功能是需要消耗CPU的！</p><pre><code class="bash">gzip on;gzip_min_length 2k;gzip_buffers   4 32k;gzip_http_version 1.1;gzip_comp_level 6;gzip_typestext/plain text/css text/javascriptapplication/json application/javascript application/x-javascriptapplication/xml;gzip_vary on;gzip_proxied any;gzip on;   #开启压缩功能gzip_min_length 1k ：设置允许压缩的页面最小字节数，页面字节数从header头的Content-Length中获取，默认值是0，不管页面多大都进行压缩，建议设置成大于1K，如果小与1K可能会越压越大。gzip_buffers 4 32k ：压缩缓冲区大小，表示申请4个单位为32K的内存作为压缩结果流缓存，默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果。gzip_http_version 1.1 ：压缩版本，用于设置识别HTTP协议版本，默认是1.1，目前大部分浏览器已经支持GZIP解压，使用默认即可。gzip_comp_level 6 ：压缩比例，用来指定GZIP压缩比，1压缩比最小，处理速度最快，9压缩比最大，传输速度快，但是处理慢，也比较消耗CPU资源。gzip_types text/css text/xml application/javascript ：用来指定压缩的类型，‘text/html’类型总是会被压缩。默认值: gzip_types text/html (默认不对js/css文件进行压缩)压缩类型，匹配MIME型进行压缩；不能用通配符 text/*；text/html默认已经压缩 (无论是否指定)；设置哪压缩种文本文件可参考 conf/mime.types。gzip_vary on ：varyheader支持，改选项可以让前端的缓存服务器缓存经过GZIP压缩的页面，例如用Squid缓存经过nginx压缩的数据。</code></pre><h3><span id="9-expires-缓存调优">9、expires 缓存调优</span></h3><p>缓存，主要针对于图片，css，js等元素更改机会比较少的情况下使用，特别是图片，占用带宽大，我们完全可以设置图片在浏览器本地缓存365d，css，js，html可以缓存个10来天，这样用户第一次打开加载慢一点，第二次，就非常快了！缓存的时候，我们需要将需要缓存的拓展名列出来， Expires缓存配置在server字段里面。</p><pre><code class="bash">location ~* \.(ico|jpe?g|gif|png|bmp|swf|flv)$ {expires 30d;#log_not_found off;access_log off;}location ~* \.(js|css)$ {expires 7d;log_not_found off;access_log off;}注：log_not_found off;是否在error_log中记录不存在的错误。默认是。</code></pre><p>总结：</p><p>expire功能优点：</p><p>expires可以降低网站购买的带宽，节约成本；</p><p>同时提升用户访问体验；</p><p>减轻服务的压力，节约服务器成本，是web服务非常重要的功能。</p><p>expire功能缺点：</p><p>被缓存的页面或数据更新了，用户看到的可能还是旧的内容，反而影响用户体验。</p><p>解决办法：第一个缩短缓存时间，例如：1天，但不彻底，除非更新频率大于1天；第二个对缓存的对象改名。</p><p>网站不希望被缓存的内容：</p><p>网站流量统计工具；</p><p>更新频繁的文件（google的logo）。</p><h3><span id="10-防盗链">10、防盗链</span></h3><p>防止别人直接从你网站引用图片等链接，消耗了你的资源和网络流量，那么我们的解决办法由几种：</p><p>水印，品牌宣传，你的带宽，服务器足够；</p><p>防火墙，直接控制，前提是你知道IP来源；</p><p>防盗链策略下面的方法是直接给予404的错误提示。</p><pre><code class="bash">location ~*^.+\.(jpg|gif|png|swf|flv|wma|wmv|asf|mp3|mmf|zip|rar)$ {valid_referers noneblocked www.benet.com benet.com;if($invalid_referer) {  #return 302 http://www.benet.com/img/nolink.jpg;  return 404;  break;}access_log off;}</code></pre><p>参数可以使如下形式：</p><p>none  ：意思是不存在的Referer头(表示空的，也就是直接访问，比如直接在浏览器打开一个图片)。</p><p>blocked  ：意为根据防火墙伪装Referer头，如：“Referer:XXXXXXX”。</p><p>server_names  ：为一个或多个服务器的列表，0.5.33版本以后可以在名称中使用“*”通配符。</p><h3><span id="11-内核参数优化">11、内核参数优化</span></h3><p>fs.file-max = 999999：这个参数表示进程（比如一个worker进程）可以同时打开的最大句柄数，这个参数直线限制最大并发连接数，需根据实际情况配置。</p><p>net.ipv4.tcp_max_tw_buckets = 6000 ：这个参数表示操作系统允许TIME_WAIT套接字数量的最大值，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。该参数默认为180000，过多的TIME_WAIT套接字会使Web服务器变慢。注：主动关闭连接的服务端会产生TIME_WAIT状态的连接</p><pre><code class="bash">net.ipv4.ip_local_port_range = 1024 65000  ：允许系统打开的端口范围。net.ipv4.tcp_tw_recycle = 1 ：启用timewait快速回收。net.ipv4.tcp_tw_reuse = 1 ：开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。这对于服务器来说很有意义，因为服务器上总会有大量TIME-WAIT状态的连接。net.ipv4.tcp_keepalive_time = 30：这个参数表示当keepalive启用时，TCP发送keepalive消息的频度。默认是2小时，若将其设置的小一些，可以更快地清理无效的连接。net.ipv4.tcp_syncookies = 1 ：开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理。net.core.somaxconn = 40960  ：web 应用中 listen 函数的 backlog 默认会给我们内核参数的。net.core.somaxconn  ：限制到128，而nginx定义的NGX_LISTEN_BACKLOG 默认为511，所以有必要调整这个值。注：对于一个TCP连接，Server与Client需要通过三次握手来建立网络连接.当三次握手成功后,我们可以看到端口的状态由LISTEN转变为ESTABLISHED,接着这条链路上就可以开始传送数据了.每一个处于监听(Listen)状态的端口,都有自己的监听队列.监听队列的长度与如somaxconn参数和使用该端口的程序中listen()函数有关。somaxconn定义了系统中每一个端口最大的监听队列的长度,这是个全局的参数,默认值为128，对于一个经常处理新连接的高负载 web服务环境来说，默认的 128 太小了。大多数环境这个值建议增加到 1024 或者更多。大的侦听队列对防止拒绝服务 DoS 攻击也会有所帮助。net.core.netdev_max_backlog = 262144  ：每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。net.ipv4.tcp_max_syn_backlog = 262144 ：这个参数标示TCP三次握手建立阶段接受SYN请求队列的最大长度，默认为1024，将其设置得大一些可以使出现Nginx繁忙来不及accept新连接的情况时，Linux不至于丢失客户端发起的连接请求。net.ipv4.tcp_rmem = 10240 87380 12582912 ：这个参数定义了TCP接受缓存（用于TCP接受滑动窗口）的最小值、默认值、最大值。net.ipv4.tcp_wmem = 10240 87380 12582912：这个参数定义了TCP发送缓存（用于TCP发送滑动窗口）的最小值、默认值、最大值。net.core.rmem_default = 6291456：这个参数表示内核套接字接受缓存区默认的大小。net.core.wmem_default = 6291456：这个参数表示内核套接字发送缓存区默认的大小。net.core.rmem_max = 12582912：这个参数表示内核套接字接受缓存区的最大大小。net.core.wmem_max = 12582912：这个参数表示内核套接字发送缓存区的最大大小。net.ipv4.tcp_syncookies = 1：该参数与性能无关，用于解决TCP的SYN攻击。</code></pre><p>下面贴一个完整的内核优化设置：</p><pre><code class="bash">fs.file-max = 999999net.ipv4.ip_forward = 0net.ipv4.conf.default.rp_filter = 1net.ipv4.conf.default.accept_source_route = 0kernel.sysrq = 0kernel.core_uses_pid = 1net.ipv4.tcp_syncookies = 1kernel.msgmnb = 65536kernel.msgmax = 65536kernel.shmmax = 68719476736kernel.shmall = 4294967296net.ipv4.tcp_max_tw_buckets = 6000net.ipv4.tcp_sack = 1net.ipv4.tcp_window_scaling = 1net.ipv4.tcp_rmem = 10240 87380 12582912net.ipv4.tcp_wmem = 10240 87380 12582912net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.core.netdev_max_backlog = 262144net.core.somaxconn = 40960net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_timestamps = 0net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_mem = 94500000 915000000 927000000net.ipv4.tcp_fin_timeout = 1net.ipv4.tcp_keepalive_time = 30net.ipv4.ip_local_port_range = 1024 65000执行sysctl  -p使内核修改生效。</code></pre><h3><span id="12-关于系统连接数的优化">12、关于系统连接数的优化</span></h3><pre><code class="bash"># linux 默认值 open files为1024。查看当前系统值：ulimit -n1024# 说明server只允许同时打开1024个文件。</code></pre><p>使用ulimit -a 可以查看当前系统的所有限制值，使用ulimit -n 可以查看当前的最大打开文件数。</p><p>新装的linux 默认只有1024 ，当作负载较大的服务器时，很容易遇到error: too many open files。因此，需要将其改大，在/etc/security/limits.conf最后增加：</p><pre><code class="bash">*               soft    nofile           65535*               hard   nofile           65535*               soft    noproc         65535*               hard   noproc         65535</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群-负载均衡</title>
      <link href="/2020/06/20/%E9%9B%86%E7%BE%A4-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2020/06/20/%E9%9B%86%E7%BE%A4-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s实战</title>
      <link href="/2020/06/20/k8s%E5%AE%9E%E6%88%98/"/>
      <url>/2020/06/20/k8s%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker实战</title>
      <link href="/2020/06/20/docker%E5%AE%9E%E6%88%98/"/>
      <url>/2020/06/20/docker%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库运维</title>
      <link href="/2020/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E7%BB%B4/"/>
      <url>/2020/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux运维常用命令</title>
      <link href="/2020/06/20/linux%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/20/linux%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1><span id="linux-常用命令">linux 常用命令</span></h1><pre><code class="bash">$ hexo new "My New Post"</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/19/hello-world/"/>
      <url>/2020/06/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3><span id="run-server">Run server</span></h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
